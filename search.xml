<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言程序的内存分布和指针简介</title>
    <url>/2020/10/25/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="C语言程序的内存分布"><a href="#C语言程序的内存分布" class="headerlink" title="C语言程序的内存分布"></a>C语言程序的内存分布</h1><p><img src="https://i.loli.net/2020/10/23/b1fLa2u3EcBZSMG.jpg" alt="1364115879_7087.jpg"></p>
<a id="more"></a>

<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p><em>只读区域，程序运行过程中无法做任何修改的存储区域，用于存放CPU执行的机器指令</em></p>
<p>通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>代码区通常是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令。</p>
<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>包括已初始化的数据段(.data)和未初始化的数据段(.bss)</p>
<p><strong>已初始化的数据段</strong>：通常简称为数据段，是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。数据段中的静态数据区存放的是程序中已初始化的<strong>全局变量、静态变量和常量</strong>。</p>
<p><strong>未初始化的数据段</strong> ：亦称BSS区，存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0。</p>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>用于动态内存分配。</p>
<p>当进程调用malloc,calloc,realloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>由编译器自动分配释放内存的区间，所得的内存空间一般都是连续的，是用来存放函数的参数值、局部变量的值、函数的返回值等。</p>
<p>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>阅读代码，思考该程序的输出是什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(a, b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> t; </span><br><span class="line">     t = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><p>在计算机中，数据是存放在内存单元中的，一般把内存中的一个字节称为一个内存单元。为了更方便地访问这些内存单元，可预先给内存中的所有内存单元进行地址编号，根据地址编号，可准确找到其对应的内存单元。由于每一个地址编号均对应一个内存单元，因此可以形象地说一个地址编号就指向一个内存单元。C 语言中把地址形象地称作指针。</p>
<p>C语言中的每个变量均对应内存中的一块内存空间，而内存中每个内存单元均是有地址编号的。在 C 语言中，可以使用运算符 &amp; 求某个变量的地址。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		    <span class="keyword">char</span> c=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);<span class="comment">//输出变量a的值</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%x\n&quot;</span>,&amp;a);<span class="comment">//输出变量a的地址</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c=%x\n&quot;</span>,&amp;c);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某次运行的结果：</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">&amp;a=<span class="number">12f</span>f40</span><br><span class="line">c=A</span><br><span class="line">&amp;c=<span class="number">12f</span>f44</span><br></pre></td></tr></table></figure>

<p>区分<strong>变量的地址值</strong>和<strong>变量的值</strong>。如上例中，变量 a 的地址值（指针值）为12ff40，而变量 a 的值为 100。</p>
<p><img src="https://i.loli.net/2020/10/24/vhnxw4NeKoPQ5rW.jpg" alt="IMG_0037(20201024-223351).PNG"></p>
<p><img src="https://i.loli.net/2020/10/23/dXrR49sACthvVSz.png" alt="屏幕截图(52).png"></p>
<p>一个指针是一个地址，是一个常量。而一个指针变量却可以被赋予不同的指针值，是变量。但是常把指针变量简称为指针。为了避免混淆，我们约定：“指针” 是指地址，是常量，“指针变量”是指取值为地址的变量。</p>
<p>指针名、数组名、函数名就是地址，它们分别表示指针所指向元素的地址、数组的首地址和函数的入口地址</p>
<h4 id="指针变量的-定义格式-为："><a href="#指针变量的-定义格式-为：" class="headerlink" title="指针变量的 定义格式 为："></a>指针变量的 <strong>定义格式</strong> 为：</h4><p>数据类型符  * 变量名;  </p>
<p>如：    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; </span><br></pre></td></tr></table></figure>



<h4 id="指针变量初始化的方法："><a href="#指针变量初始化的方法：" class="headerlink" title="指针变量初始化的方法："></a>指针变量初始化的方法：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//&amp;为取址运算符，&amp;a即为取a的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// p指向a ，相当于*p就是a的别名</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 相当于 a = 10;</span></span><br></pre></td></tr></table></figure>



<h3 id="void-类型指针"><a href="#void-类型指针" class="headerlink" title="void*类型指针"></a>void*类型指针</h3><p>表示形式为 void*p;表示<strong>不指定 p 是指向哪一种数据类型的指针变量</strong>。使用时要进行强制类型转换。例如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2;  </span><br><span class="line"></span><br><span class="line">p1 = (<span class="keyword">char</span> *)p2;  </span><br><span class="line"></span><br><span class="line">p2 = (<span class="keyword">void</span> *)p1;</span><br></pre></td></tr></table></figure>



<h3 id="空指针NULL"><a href="#空指针NULL" class="headerlink" title="空指针NULL"></a>空指针NULL</h3><p>在C语言中，如果一个指针不指向任何数据，我们就称之为空指针，用NULL</p>
<p> 表示。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。</p>
<p>NULL 是一个宏定义，在stdio.h被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>



<p>我们知道，变量一旦定义就要分配内存，指针变量也是如此。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;  <span class="comment">//它不是空指针</span></span><br></pre></td></tr></table></figure>

<p>它的值是随机的，是垃圾值，如果不小心使用了它，运行时一般会引起段错误，导致程序退出，甚至会不知不觉地修改数据。</p>
<p><strong>所以，为了实现交换两个数的值的功能，可以将形参改为接收实参的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(&amp;a, &amp;b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc 与 free"></a>malloc 与 free</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><hr>
<p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void malloc(size_t size)</code></p>
<p><em>所以需要根据实际你需要的类型对其强制类型转换</em></p>
<p><strong>返回值</strong></p>
<p>成功时，返回指向新分配内存的指针。<br>失败时，返回空指针（NULL）</p>
<p><strong>参数：</strong>size : 要分配的字节数</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><hr>
<p><strong>头文件</strong>：<code>stdlib</code><br><strong>原型</strong>：<code>void free( void* ptr );</code><br><strong>参数</strong>：指向要解分配的内存的指针<br><strong>返回值</strong>：无</p>
<p>我们需要一个大小为 N ( N &lt; 1000)的数组,我们可能会想写成arr[N]，由输入决定数组的大小，但是这样写编译会出错。</p>
<p>所以我们通常这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的不确定可能会造成空间的浪费。</p>
<p>其实我们可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* arr &#x3D; (int*)malloc(sizeof(int) * N)</span><br></pre></td></tr></table></figure>

<p>该代码定义了一个指针arr指向sizeof(int) * N这么大的空间</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/02/hello-world/</url>
    <content><![CDATA[<p>We=lcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/29/Activity%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Activity的基本状态"><a href="#Activity的基本状态" class="headerlink" title="Activity的基本状态"></a>Activity的基本状态</h3><hr>
<h4 id="活动状态-running"><a href="#活动状态-running" class="headerlink" title="活动状态(running)"></a>活动状态(running)</h4><p>活动状态一般是指该Activity正处于屏幕最显著的位置上显示，即该Activity是在Android活动栈的最顶端。 此时它处于可见并可和用户交互的状态。</p>
<h4 id="暂停状态-paused"><a href="#暂停状态-paused" class="headerlink" title="暂停状态(paused)"></a><strong>暂停状态(paused)</strong></h4><p>暂停状态一般指该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。不可以触摸操作。失去焦点即被一个新的非全屏的Activity或者一个透明的Activity覆盖</p>
<a id="more"></a>

<h4 id="停止状态-stopped"><a href="#停止状态-stopped" class="headerlink" title="停止状态(stopped)"></a><strong>停止状态(stopped)</strong></h4><p>停止状态一般指该Activity被另一个Activity完全覆盖的状态</p>
<p>此状态下，该Activity的数据会暂时保留，但是，一旦系统需要内存，这种处于Stopped状态的Activity占用的空间会优先被清理并重新利用</p>
<h4 id="销毁状态-killed"><a href="#销毁状态-killed" class="headerlink" title="销毁状态(killed)"></a>销毁状态(killed)</h4><p>此时Activity已从Activity栈中移除，在内存中不存在</p>
<h3 id="Activity的状态转换"><a href="#Activity的状态转换" class="headerlink" title="Activity的状态转换"></a>Activity的状态转换</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/sfaq5YNBzuGKWvb.png" alt="屏幕截图(65).png"></p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/bUiop372zD6X8gx.png" alt="屏幕截图(63).png"></p>
<p><strong><em>onCreate ( )</em></strong>: 首次创建Activity时调用。进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。</p>
<p><strong><em>onStart ( )</em></strong> : 此时Activity已经<strong>可见</strong>了，但是还在后台，我们还看不到，无法与Activity交互。可以理解为Activity已经显示出来了，但是我们还看不见</p>
<p><strong><em>onResume ( )</em></strong> : Activity在这个阶段已经出现在前台并且<strong>可见</strong>了（处于running状态）。</p>
<p><strong><em>onPause ( )</em></strong> :表示暂停(paused状态），当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且Android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。</p>
<p><strong><em>onStop ( )</em></strong> :表示即将停止，此时Activity不可见。当Activity即将被销毁或被另一个Activity覆盖，则会调用onStop。如果新的Activity采用了透明主题，则不会回调onStop。这个阶段可以做一些微重量级的回收工作，同样不能太耗时。</p>
<p><strong><em>onDestroy ( )</em></strong> : Activity被销毁时调用。点击返回键或Activity里调用了finish方法或系统内存不足而选择强杀app时会调用onDestroy。在这里可以做一些回收工作和最终的资源释放。</p>
<p><strong><em>onRestart( )</em></strong> ：表示重新开始，Activity在这时<strong>可见</strong>，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>从整个生命周期来说，*<strong>onCreate**<em>和</em></strong>onDestroy***是配对的，分别标识着Activity的创建和销毁，并且只会调用一次。</p>
<p>从Activity是否在前台来说，*<strong>onResume**<em>和</em></strong>onPause***是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<p>从Activity是否可见来说，*<strong>onStart**<em>和</em></strong>onStop***是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<h4 id="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"><a href="#打开一个app的MainActivity并跳转到另一个Activity时的生命周期" class="headerlink" title="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"></a>打开一个app的MainActivity并跳转到另一个Activity时的生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;某一个Activity第一次启动，回调为：onCreate-&gt;onStart-&gt;onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onResume</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳转到下一个Activity时</span><br><span class="line">当需要从MainActivity切换到SecondActivity时，先执行MainActivity中的与onResume()相对应的onPause()操作，比如关闭独占设备(比如相机），或其它耗费cpu的操作；</span><br><span class="line">以防SecondActivity也需要使用这些资源，关闭耗CPU的操作，也有利于SecondActivity运行的流畅。</span><br><span class="line"></span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onPause</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate"><a href="#为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate" class="headerlink" title="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?"></a>为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?</h4><p>从用户体验的角度来分析,当用户触发某事件切换到新的Activity，用户肯定是想尽快进入新的视图进行操作。<br>MainActivity中比较消耗资源的部分在onPause时关闭后，再切换到SecondActivity中执行SecondActivity<br>的初始化，显示SecondActivity中的View后，用户可以进行交互。</p>
<p>此时后台再去执行MainActivity的onStop()操作，即使这里面有些比较耗时的操作，也没有关系，这是在后台执行所以也不影响用户的体验。</p>
<h3 id="Activity的优先级"><a href="#Activity的优先级" class="headerlink" title="Activity的优先级"></a>Activity的优先级</h3><hr>
<p>从高到低：</p>
<p>(1)前台Activity——正在与用户交互的Activity，优先级最高</p>
<p>(2)可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但位于后台无法和用户直接交互</p>
<p>(3)后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低</p>
<p>当系统内存不足时，会按照上述优先级去杀死Activity所在进程。</p>
<h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><hr>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p><strong>标准模式</strong>：如果不设置Activity的启动模式，系统会默认将其设置为standard。</p>
<p>这种模式下，同一个Activity可以有多个实例，每次启动Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。</p>
<p><img src="https://i.loli.net/2020/11/29/bnKkBhFUXQwjSmY.png" alt="20180606100919308.png"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p><strong>栈顶复用模式</strong>：在这种模式下，如果新启动的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建。</p>
<p>如果新Activity的实例已存在但不位于栈顶，那么新Activity仍会重新创建。</p>
<p><img src="https://i.loli.net/2020/11/29/lUGdxmt6nOkog5X.png" alt="2.png"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p><strong>栈内复用模式</strong>：这是一种单实例模式，一个栈中同一个Activity只存在唯一一个实例，无论是否在栈顶，只要存在实例，都不会重新创建。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶。会导致任务栈内它上面的Activity被销毁。</p>
<p><img src="https://i.loli.net/2020/11/29/mOZjVPEzFMqaH3k.png" alt="3.png"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p><strong>单实例模式</strong>：这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是此种模式的Activity只能单独地位于一个任务栈中，不同的应用去打开这个Activity 共用同一个Activity。在该模式下，我们会为目标Activity创建一个新的任务栈，将目标Activity放入新的任务栈，由于栈内复用的特性，后续的请求不会创建新的Activity，除非这个独特的任务栈被系统销毁了。</p>
<p><img src="https://i.loli.net/2020/11/29/uxdQ1EsDAoCOfIt.png" alt="4.png"></p>
]]></content>
  </entry>
</search>
