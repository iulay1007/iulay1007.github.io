<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言程序的内存分布和指针简介</title>
    <url>/2020/10/25/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="C语言程序的内存分布"><a href="#C语言程序的内存分布" class="headerlink" title="C语言程序的内存分布"></a>C语言程序的内存分布</h1><p><img src="https://i.loli.net/2020/10/23/b1fLa2u3EcBZSMG.jpg" alt="1364115879_7087.jpg"></p>
<a id="more"></a>

<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p><em>只读区域，程序运行过程中无法做任何修改的存储区域，用于存放CPU执行的机器指令</em></p>
<p>通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>代码区通常是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令。</p>
<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>包括已初始化的数据段(.data)和未初始化的数据段(.bss)</p>
<p><strong>已初始化的数据段</strong>：通常简称为数据段，是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。数据段中的静态数据区存放的是程序中已初始化的<strong>全局变量、静态变量和常量</strong>。</p>
<p><strong>未初始化的数据段</strong> ：亦称BSS区，存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0。</p>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>用于动态内存分配。</p>
<p>当进程调用malloc,calloc,realloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>由编译器自动分配释放内存的区间，所得的内存空间一般都是连续的，是用来存放函数的参数值、局部变量的值、函数的返回值等。</p>
<p>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>阅读代码，思考该程序的输出是什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(a, b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> t; </span><br><span class="line">     t = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><p>在计算机中，数据是存放在内存单元中的，一般把内存中的一个字节称为一个内存单元。为了更方便地访问这些内存单元，可预先给内存中的所有内存单元进行地址编号，根据地址编号，可准确找到其对应的内存单元。由于每一个地址编号均对应一个内存单元，因此可以形象地说一个地址编号就指向一个内存单元。C 语言中把地址形象地称作指针。</p>
<p>C语言中的每个变量均对应内存中的一块内存空间，而内存中每个内存单元均是有地址编号的。在 C 语言中，可以使用运算符 &amp; 求某个变量的地址。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		    <span class="keyword">char</span> c=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);<span class="comment">//输出变量a的值</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%x\n&quot;</span>,&amp;a);<span class="comment">//输出变量a的地址</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c=%x\n&quot;</span>,&amp;c);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某次运行的结果：</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">&amp;a=<span class="number">12f</span>f40</span><br><span class="line">c=A</span><br><span class="line">&amp;c=<span class="number">12f</span>f44</span><br></pre></td></tr></table></figure>

<p>区分<strong>变量的地址值</strong>和<strong>变量的值</strong>。如上例中，变量 a 的地址值（指针值）为12ff40，而变量 a 的值为 100。</p>
<p><img src="https://i.loli.net/2020/10/24/vhnxw4NeKoPQ5rW.jpg" alt="IMG_0037(20201024-223351).PNG"></p>
<p><img src="https://i.loli.net/2020/10/23/dXrR49sACthvVSz.png" alt="屏幕截图(52).png"></p>
<p>一个指针是一个地址，是一个常量。而一个指针变量却可以被赋予不同的指针值，是变量。但是常把指针变量简称为指针。为了避免混淆，我们约定：“指针” 是指地址，是常量，“指针变量”是指取值为地址的变量。</p>
<p>指针名、数组名、函数名就是地址，它们分别表示指针所指向元素的地址、数组的首地址和函数的入口地址</p>
<h4 id="指针变量的-定义格式-为："><a href="#指针变量的-定义格式-为：" class="headerlink" title="指针变量的 定义格式 为："></a>指针变量的 <strong>定义格式</strong> 为：</h4><p>数据类型符  * 变量名;  </p>
<p>如：    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; </span><br></pre></td></tr></table></figure>



<h4 id="指针变量初始化的方法："><a href="#指针变量初始化的方法：" class="headerlink" title="指针变量初始化的方法："></a>指针变量初始化的方法：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//&amp;为取址运算符，&amp;a即为取a的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// p指向a ，相当于*p就是a的别名</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 相当于 a = 10;</span></span><br></pre></td></tr></table></figure>



<h3 id="void-类型指针"><a href="#void-类型指针" class="headerlink" title="void*类型指针"></a>void*类型指针</h3><p>表示形式为 void*p;表示<strong>不指定 p 是指向哪一种数据类型的指针变量</strong>。使用时要进行强制类型转换。例如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2;  </span><br><span class="line"></span><br><span class="line">p1 = (<span class="keyword">char</span> *)p2;  </span><br><span class="line"></span><br><span class="line">p2 = (<span class="keyword">void</span> *)p1;</span><br></pre></td></tr></table></figure>



<h3 id="空指针NULL"><a href="#空指针NULL" class="headerlink" title="空指针NULL"></a>空指针NULL</h3><p>在C语言中，如果一个指针不指向任何数据，我们就称之为空指针，用NULL</p>
<p> 表示。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。</p>
<p>NULL 是一个宏定义，在stdio.h被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>



<p>我们知道，变量一旦定义就要分配内存，指针变量也是如此。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;  <span class="comment">//它不是空指针</span></span><br></pre></td></tr></table></figure>

<p>它的值是随机的，是垃圾值，如果不小心使用了它，运行时一般会引起段错误，导致程序退出，甚至会不知不觉地修改数据。</p>
<p><strong>所以，为了实现交换两个数的值的功能，可以将形参改为接收实参的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(&amp;a, &amp;b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc 与 free"></a>malloc 与 free</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><hr>
<p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void malloc(size_t size)</code></p>
<p><em>所以需要根据实际你需要的类型对其强制类型转换</em></p>
<p><strong>返回值</strong></p>
<p>成功时，返回指向新分配内存的指针。<br>失败时，返回空指针（NULL）</p>
<p><strong>参数：</strong>size : 要分配的字节数</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><hr>
<p><strong>头文件</strong>：<code>stdlib</code><br><strong>原型</strong>：<code>void free( void* ptr );</code><br><strong>参数</strong>：指向要解分配的内存的指针<br><strong>返回值</strong>：无</p>
<p>我们需要一个大小为 N ( N &lt; 1000)的数组,我们可能会想写成arr[N]，由输入决定数组的大小，但是这样写编译会出错。</p>
<p>所以我们通常这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的不确定可能会造成空间的浪费。</p>
<p>其实我们可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* arr &#x3D; (int*)malloc(sizeof(int) * N)</span><br></pre></td></tr></table></figure>

<p>该代码定义了一个指针arr指向sizeof(int) * N这么大的空间</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/02/hello-world/</url>
    <content><![CDATA[<p>We=lcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/29/Activity%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Activity的基本状态"><a href="#Activity的基本状态" class="headerlink" title="Activity的基本状态"></a>Activity的基本状态</h3><hr>
<h4 id="活动状态-running"><a href="#活动状态-running" class="headerlink" title="活动状态(running)"></a>活动状态(running)</h4><p>活动状态一般是指该Activity正处于屏幕最显著的位置上显示，即该Activity是在Android活动栈的最顶端。 此时它处于可见并可和用户交互的状态。</p>
<h4 id="暂停状态-paused"><a href="#暂停状态-paused" class="headerlink" title="暂停状态(paused)"></a><strong>暂停状态(paused)</strong></h4><p>暂停状态一般指该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。不可以触摸操作。失去焦点即被一个新的非全屏的Activity或者一个透明的Activity覆盖</p>
<a id="more"></a>

<h4 id="停止状态-stopped"><a href="#停止状态-stopped" class="headerlink" title="停止状态(stopped)"></a><strong>停止状态(stopped)</strong></h4><p>停止状态一般指该Activity被另一个Activity完全覆盖的状态</p>
<p>此状态下，该Activity的数据会暂时保留，但是，一旦系统需要内存，这种处于Stopped状态的Activity占用的空间会优先被清理并重新利用</p>
<h4 id="销毁状态-killed"><a href="#销毁状态-killed" class="headerlink" title="销毁状态(killed)"></a>销毁状态(killed)</h4><p>此时Activity已从Activity栈中移除，在内存中不存在</p>
<h3 id="Activity的状态转换"><a href="#Activity的状态转换" class="headerlink" title="Activity的状态转换"></a>Activity的状态转换</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/sfaq5YNBzuGKWvb.png" alt="屏幕截图(65).png"></p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/bUiop372zD6X8gx.png" alt="屏幕截图(63).png"></p>
<p><strong><em>onCreate ( )</em></strong>: 首次创建Activity时调用。进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。</p>
<p><strong><em>onStart ( )</em></strong> : 此时Activity已经<strong>可见</strong>了，但是还在后台，我们还看不到，无法与Activity交互。可以理解为Activity已经显示出来了，但是我们还看不见</p>
<p><strong><em>onResume ( )</em></strong> : Activity在这个阶段已经出现在前台并且<strong>可见</strong>了（处于running状态）。</p>
<p><strong><em>onPause ( )</em></strong> :表示暂停(paused状态），当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且Android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。</p>
<p><strong><em>onStop ( )</em></strong> :表示即将停止，此时Activity不可见。当Activity即将被销毁或被另一个Activity覆盖，则会调用onStop。如果新的Activity采用了透明主题，则不会回调onStop。这个阶段可以做一些微重量级的回收工作，同样不能太耗时。</p>
<p><strong><em>onDestroy ( )</em></strong> : Activity被销毁时调用。点击返回键或Activity里调用了finish方法或系统内存不足而选择强杀app时会调用onDestroy。在这里可以做一些回收工作和最终的资源释放。</p>
<p><strong><em>onRestart( )</em></strong> ：表示重新开始，Activity在这时<strong>可见</strong>，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。</p>
<p>从整个生命周期来说，onCreate和onDestroy是配对的，分别标识着Activity的创建和销毁，并且只会调用一次。</p>
<p>从Activity是否在前台来说，onResume和onPause是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<p>从Activity是否可见来说，onStart和onStop是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<h4 id="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"><a href="#打开一个app的MainActivity并跳转到另一个Activity时的生命周期" class="headerlink" title="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"></a>打开一个app的MainActivity并跳转到另一个Activity时的生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;某一个Activity第一次启动，回调为：onCreate-&gt;onStart-&gt;onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onResume</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳转到下一个Activity时</span><br><span class="line">当需要从MainActivity切换到SecondActivity时，先执行MainActivity中的与onResume()相对应的onPause()操作，比如关闭独占设备(比如相机），或其它耗费cpu的操作；</span><br><span class="line">以防SecondActivity也需要使用这些资源，关闭耗CPU的操作，也有利于SecondActivity运行的流畅。</span><br><span class="line"></span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onPause</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate"><a href="#为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate" class="headerlink" title="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?"></a>为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?</h4><p>从用户体验的角度来分析,当用户触发某事件切换到新的Activity，用户肯定是想尽快进入新的视图进行操作。<br>MainActivity中比较消耗资源的部分在onPause时关闭后，再切换到SecondActivity中执行SecondActivity<br>的初始化，显示SecondActivity中的View后，用户可以进行交互。</p>
<p>此时后台再去执行MainActivity的onStop()操作，即使这里面有些比较耗时的操作，也没有关系，这是在后台执行所以也不影响用户的体验。</p>
<h3 id="Activity的优先级"><a href="#Activity的优先级" class="headerlink" title="Activity的优先级"></a>Activity的优先级</h3><hr>
<p>从高到低：</p>
<p>(1)前台Activity——正在与用户交互的Activity，优先级最高</p>
<p>(2)可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但位于后台无法和用户直接交互</p>
<p>(3)后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低</p>
<p>当系统内存不足时，会按照上述优先级去杀死Activity所在进程。</p>
<h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><hr>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p><strong>标准模式</strong>：如果不设置Activity的启动模式，系统会默认将其设置为standard。</p>
<p>这种模式下，同一个Activity可以有多个实例，每次启动Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。</p>
<p><img src="https://i.loli.net/2020/11/29/bnKkBhFUXQwjSmY.png" alt="20180606100919308.png"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p><strong>栈顶复用模式</strong>：在这种模式下，如果新启动的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建。</p>
<p>如果新Activity的实例已存在但不位于栈顶，那么新Activity仍会重新创建。</p>
<p><img src="https://i.loli.net/2020/11/29/lUGdxmt6nOkog5X.png" alt="2.png"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p><strong>栈内复用模式</strong>：这是一种单实例模式，一个栈中同一个Activity只存在唯一一个实例，无论是否在栈顶，只要存在实例，都不会重新创建。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶。会导致任务栈内它上面的Activity被销毁。</p>
<p><img src="https://i.loli.net/2020/11/29/mOZjVPEzFMqaH3k.png" alt="3.png"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p><strong>单实例模式</strong>：这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是此种模式的Activity只能单独地位于一个任务栈中，不同的应用去打开这个Activity 共用同一个Activity。在该模式下，我们会为目标Activity创建一个新的任务栈，将目标Activity放入新的任务栈，由于栈内复用的特性，后续的请求不会创建新的Activity，除非这个独特的任务栈被系统销毁了。</p>
<p><img src="https://i.loli.net/2020/11/29/uxdQ1EsDAoCOfIt.png" alt="4.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/13/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Java中对象的访问方式"><a href="#Java中对象的访问方式" class="headerlink" title="Java中对象的访问方式"></a>Java中对象的访问方式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，<strong>并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置</strong>，所以对象访问方式也是<strong>取决于虚拟机实现的</strong>。目前主流的访问方式有使用<strong>句柄和直接指针</strong>两种</p>
<a id="more"></a>



<h3 id="使用句柄的访问方式"><a href="#使用句柄的访问方式" class="headerlink" title="使用句柄的访问方式"></a><strong>使用句柄的访问方式</strong></h3><hr>
<p>如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。对象实例数据一般在堆中开辟，类型数据一般储存在方法区中。</p>
<p><img src="https://i.loli.net/2021/03/12/NHmak9JWL5p3qzf.jpg" alt="1117609-20200327223929343-1244300162.jpg"></p>
<h3 id="使用直接指针的访问方式"><a href="#使用直接指针的访问方式" class="headerlink" title="使用直接指针的访问方式"></a>使用直接指针的访问方式</h3><hr>
<p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要在实例中存储</p>
<p><img src="https://i.loli.net/2021/03/12/7tOdcWXrkMUfhPT.jpg" alt="1117609-20200327223943696-1024093458.jpg"></p>
<h3 id="两种对象访问方式的区别"><a href="#两种对象访问方式的区别" class="headerlink" title="两种对象访问方式的区别"></a>两种对象访问方式的区别</h3><hr>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销， 由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。但它的缺点是，当对象被移动时（如进行GC后的内存重新排列），对象的引用（reference）也需要同步更新</p>
<h2 id="Java中的四大引用"><a href="#Java中的四大引用" class="headerlink" title="Java中的四大引用"></a>Java中的四大引用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    在很多时候，我们对于一个对象的存活时长要求是不一样的，这通常表现为我们希望的垃圾回收器对它的回收时机的不同。对于一些比较重要的对象，我们希望垃圾回收器永远不去回收它，即使此时内存空间已经不足了，因为一旦它被回收，将导致严重的后果。而对于一些不那么重要的对象，比如在做图片缓存的时候生成的大量图片的缓存对象，我们希望垃圾回收器只在内存不足的情况下去对它进行回收以提升用户体验</p>
<p>​    一般来说内存泄漏有两种情况。一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）；另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。第一种情况，在 Java 中已经由于垃圾回收机制的引入，得到了很好的解决。所以， Java 中的内存泄漏，主要指的是第二种情况。</p>
<p>​    而我们知道，在Java中垃圾回收器的运行是JVM操作的，但是我们仍然可以在一定程度上与垃圾回收器进行交互，其目的在于更好的帮助垃圾回收器管理好应用的内存。  从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><hr>
<p>强引用就是在程序代码普遍存在的例如Object object=new Object（）这类的引用；如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a><strong>软引用(Soft Reference)</strong></h3><hr>
<p>​    软引用用来描述一些有用但非必需的对象。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。**<em>就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收**</em>。</p>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a><strong>弱引用（Weak Reference）</strong></h3><hr>
<p>​    弱引用也用来描述非必需的对象。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，被弱引用关联的对象只能生存到下一次垃圾收集发生前。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a><strong>虚引用（Phantom Reference）</strong></h3><hr>
<p>​      “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会影响与之关联的对象的生存时间，也无法通过虚引用来取得一个对象的实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，<strong>来了解被引用的对象是否将要被垃圾回收，即在这个对象被回收时可以得到通知</strong>。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(  <span class="string">&quot; hello &quot;</span> );</span><br><span class="line">     ReferenceQueue&lt; String &gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue &lt; String &gt; ();</span><br><span class="line">     <span class="comment">//SoftReference&lt; String &gt; reference = new SoftReference &lt; String &gt; (str, referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     无论是否调用System.gc()，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     一个对象只具有软引用，内存不足时才回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     WeakReference&lt; String &gt; reference = <span class="keyword">new</span> WeakReference &lt; String &gt; (str, 		referenceQueue);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有进行垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     进行垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.WeakReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象只具有弱引用，在垃圾回收器线程扫描它所管辖的内存区域的过程中，</span></span><br><span class="line"><span class="comment">     一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//PhantomReference&lt;String&gt; reference = new PhantomReference&lt;String&gt;(str,referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有被垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     被垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.PhantomReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象仅持有虚引用，那么它就和没有任何引用一样，</span></span><br><span class="line"><span class="comment">     在任何时候都可能被垃圾回收*/</span></span><br><span class="line"></span><br><span class="line">     str = <span class="keyword">null</span> ;  <span class="comment">// 取消&quot;hello&quot;对象的强引用</span></span><br><span class="line">     System.gc();</span><br><span class="line">     String str1 = reference.get();</span><br><span class="line">     System.out.println(str1);</span><br><span class="line">     System.out.println(referenceQueue.poll());</span><br></pre></td></tr></table></figure>



<p>如图，“hello”对象同时具有强引用和弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/g73ROq9vGZMpzdh.png" alt="6ae1becb-74c0-3c51-9602-9a2d7cf7dbf9.png"></p>
<p>当str为null，“hello”对象不再具有强引用，而只具有弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/CbEAo3MBj5Fmi1e.png" alt="aad88dc6-7d9e-30da-a705-c66cf94bfa46.png"></p>
<h3 id="引用的区别与选择"><a href="#引用的区别与选择" class="headerlink" title="引用的区别与选择"></a>引用的区别与选择</h3><hr>
<p><img src="https://i.loli.net/2021/03/11/OLu2gwoP46xBsNE.png" alt="屏幕截图(149).png"></p>
<ul>
<li><p>SoftReference 具有构建 Cache 系统的特质，因此我们可以结合哈希表实现一个简单的缓存系统。这样既能保证能够尽可能多的缓存信息，又可以保证 Java虚拟机不会因为内存泄露而抛出  OutOfMemoryError  。这种缓存机制特别适合于内存对象生命周期长，且生成内存对象的耗时比较长的情况，例如缓存列表封面图片等。对于一些生命周期较长，但是生成内存对象开销不大的情况，使用WeakReference 能够达到更好的内存管理的效果。 </p>
</li>
<li><p>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用</p>
</li>
</ul>
<h3 id="Handler-可能引起的内存泄漏"><a href="#Handler-可能引起的内存泄漏" class="headerlink" title="Handler 可能引起的内存泄漏"></a>Handler 可能引起的内存泄漏</h3><hr>
<p>我们经常会写这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>当你这样写的时候，你一定会收到编译器的黄色警告。</p>
<blockquote>
<p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p>
</blockquote>
<p><strong>在 Java 中，非静态的内部类和匿名内部类都会 <em>隐式地</em>  持有其外部类的引用</strong>。由于Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也不可能被释放，当一个对象已经不需要再使用了，本来该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</p>
<p>要解决这样的问题，我们在继承 <code>Handler</code> 的时候，要么是放在单独的类文件中，要么直接使用静态内部类，静态的内部类不会持有外部类的引用。当需要在静态内部类中调用外部的 Activity 的时候，我们可以直接采用<strong>弱引用</strong>进行处理，所以我们大概修改后的代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span></span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            MainActivity activity = mWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始写业务代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> MyHandler mMyHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>其实在我们实际开发中，不止一个地方可能会用到内部类，我们都需要在这样的情况下尽量使用静态内部类加弱引用的方式解决我们可能出现的内存泄漏问题。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/27/Handler/</url>
    <content><![CDATA[<h3 id="为什么需要Handler"><a href="#为什么需要Handler" class="headerlink" title="为什么需要Handler"></a>为什么需要Handler</h3><hr>
<p>Handler的主要作用是将一个任务切换到某个指定的指定的线程中执行。而Handler常常可以用于在子线程更新UI。</p>
<p>系统为什么不允许在子线程更新UI呢？这是因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那么为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂；其次，锁机制会降低UI的访问效率，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换一下UI访问的执行线程即可。</p>
<a id="more"></a>



<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>Handler运行需要底层的MessageQueue和Looper支撑。其中MessageQueue采用的是单链表的结构，Looper可以叫做消息循环。由于MessageQueue只是一个消息存储单元，不能去处理消息，而Looper就是专门来处理消息的，Looper会以无限循环的形式去查找是否有新消息，如果有的话，就处理，否则就一直等待着。</p>
<p>当Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。注意Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。</p>
<p>我们知道，Handler创建的时候会采用 <strong><em>当前线程</em></strong> 的Looper来构造消息循环系统，需要注意的是，线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper，因为默认的UI主线程，也就是ActivityThread，ActivityThread被创建的时候就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><blockquote>
<p>定义：是线程间通讯的数据单元，包含着描述信息及任意数据对象，发送到 Handler。</p>
</blockquote>
<p>在实际使用中，我们在工作线程中通过 Handler.sendMessage(Message)，将携带数据的 Message 信息发送给 Handler，然后再由 Handler 处理，根据不同的信息，通知主线程作出相对应的 UI 工作。</p>
<h4 id="MessageQueue-消息队列"><a href="#MessageQueue-消息队列" class="headerlink" title="MessageQueue 消息队列"></a>MessageQueue 消息队列</h4><blockquote>
<p>定义：用来存储 Message 的数据队列。</p>
</blockquote>
<p>主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作。插入对应的方法为enqueueMessage，读取对应的方法为next。next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next会返回这条消息并将其从单链表中移除。</p>
<h4 id="Looper-消息循环器"><a href="#Looper-消息循环器" class="headerlink" title="Looper 消息循环器"></a>Looper 消息循环器</h4><blockquote>
<p>定义：用于为线程执行消息循环的一个类。是 MessageQueue 与 Handler 之间的通讯媒介。</p>
</blockquote>
<p>会不停地从MessageQueue中查看是否有新消息，如果有新消息就立即处理，否则就一直阻塞在那里。</p>
<p>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态。而**如果退出Looper以后，这个线程就会立刻终止 **。因此建议在不需要的时候终止Looper</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="https://i.loli.net/2021/03/27/n4dvK1o3k8MgyPH.png" alt="20200104121245311.png"></p>
<p>存储在 <strong>MessageQueue</strong> 中的 <strong>Message</strong> 被 <strong>Looper</strong> 循环分发到指定的 <strong>Handler</strong> 中进行处理</p>
<ul>
<li>一个 Thread 可以有多个 Handler。</li>
<li>但一个 Thread 只能有一个 Looper，即在该线程调用Looper.prepare()创建的Looper</li>
<li>一个 Handler 只能关联一个 Looper 对象，即创建Handler线程的Looper</li>
<li>反之，一个 Looper 可以被多个 Handler 所关联</li>
<li>一个Looper创建一个MessageQueue</li>
</ul>
<h3 id="Handler的构造方法"><a href="#Handler的构造方法" class="headerlink" title="Handler的构造方法"></a>Handler的构造方法</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h3><hr>
<h4 id="1-新建Handler子类（内部类）"><a href="#1-新建Handler子类（内部类）" class="headerlink" title="1.新建Handler子类（内部类）"></a>1.新建Handler子类（内部类）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：（自定义）新创建Handler子类(继承Handler类) &amp; 复写handleMessage（）方法</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mhandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据不同线程发送过来的消息，执行不同的UI操作</span></span><br><span class="line">            <span class="comment">// 根据 Message对象的what属性 标识不同的消息</span></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Mhandler();</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用2个工作线程展示</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过sendMessage（）发送</span></span><br><span class="line">                 <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">                 <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 根据不同线程发送过来的消息，执行不同的UI操作</span></span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-Handler-post（Runnable）"><a href="#3-Handler-post（Runnable）" class="headerlink" title="3.Handler.post（Runnable）"></a>3.Handler.post（Runnable）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过psot（）发送，需传入1个Runnable对象</span></span><br><span class="line">                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 指定操作UI内容</span></span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>先看一下sendMessage的源码分析一下执行过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">           Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现，Handler发送消息的过程仅仅是向消息队列插入了一条消息（调用MessageQueue的enqueueMessage方法）。MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理，最终交由Handler处理。即Handler的dispatchMessage方法被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handleCallback(msg);</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          handleMessage(msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Handler处理消息的过程如下：</p>
<p>首先，检查Message的callback（msg.callback）是否为null，不为null就通过handleCallback来处理消息。这里的msg.callback即为Handler的post方法传进来的Runnable对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.obj = token;</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>其次检查mCallback是否为null。不为null就调用mCallback的HandleMessage方法来处理消息。Callback是个接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>通过Callback可以通过Handler handler=new Handler(callback)来创建Handler对象。其作用在于可以用来创建Handler实例而不需要派生Handler的子类</p>
<p>最后调用Handler的handleMessage方法来处理消息。handleMessage方法是Handler子类需要实现的。</p>
<h3 id="子线程创建Handler"><a href="#子线程创建Handler" class="headerlink" title="子线程创建Handler"></a>子线程创建Handler</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomChildThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//为当前线程创建一个 Looper 对象</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//在子线程中创建一个 Handler 对象</span></span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 在这里处理传入的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开始消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/15/ViewPager/</url>
    <content><![CDATA[<h1 id="ViewPager及懒加载与预加载分析"><a href="#ViewPager及懒加载与预加载分析" class="headerlink" title="ViewPager及懒加载与预加载分析"></a>ViewPager及懒加载与预加载分析</h1><h2 id="ViewPager的使用"><a href="#ViewPager的使用" class="headerlink" title="ViewPager的使用"></a>ViewPager的使用</h2><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><hr>
<p>网上一些教程上会运用以下方式在PagerAdapter中获取Fragment实例，即在构造PagerAdapter时传入相应的Fragment列表，也就是在构造PagerAdapter前已经将所有Fragment进行了初始化。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Fragment&gt; fragmentList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestFragmentPagerAdapter</span><span class="params">(FragmentManager fm, List&lt;Fragment&gt; fragmentList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        <span class="keyword">this</span>.fragmentList = fragmentList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fragmentList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fragmentList.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="官方用法"><a href="#官方用法" class="headerlink" title="官方用法"></a>官方用法</h3><hr>
<p>但查看官方示例代码可发现，官方更加倾向于以下创建Fragment实例的方式。即在getItem()中开始创建实例，而非将所有实例创建好然后传入PagerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> NUM_ITEMS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ArrayListFragment.newInstance(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *ListFragment is the same as a ListActivity - it&#x27;s just a Fragment,</span></span><br><span class="line"><span class="comment">     *that extends List methods. You can just add Fragment, that contains ListView and implement</span></span><br><span class="line"><span class="comment">     *all required for list methods, like in Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create a new instance of CountingFragment, providing &quot;num&quot;</span></span><br><span class="line"><span class="comment">         * as an argument.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> ArrayListFragment <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            ArrayListFragment f = <span class="keyword">new</span> ArrayListFragment();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Supply num input as an argument.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            为什么不通过构造函数直接传参数？详见</span></span><br><span class="line"><span class="comment">https://blog.csdn.net/tu_bingbing/article/details/24143249</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">            args.putInt(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">            f.setArguments(args);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * When creating, retrieve this instance&#x27;s number from its arguments.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            mNum = getArguments() != <span class="keyword">null</span> ? getArguments().getInt(<span class="string">&quot;num&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The Fragment&#x27;s UI is just a simple text view showing its</span></span><br><span class="line"><span class="comment">         * instance number.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            View v = inflater.inflate(R.layout.fragment_pager_list, container, <span class="keyword">false</span>);</span><br><span class="line">            View tv = v.findViewById(R.id.text);</span><br><span class="line">            ((TextView) tv).setText(<span class="string">&quot;Fragment #&quot;</span> + mNum);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">            setListAdapter(<span class="keyword">new</span> ArrayAdapter&lt;String&gt;(getActivity(),</span><br><span class="line">                    android.R.layout.simple_list_item_1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">            Log.i(<span class="string">&quot;FragmentList&quot;</span>, <span class="string">&quot;Item clicked: &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>getItem()方法中创建实例也可以使用工厂模式</p>
</blockquote>
<p>为什么不推荐提前初始化所有Fragment？</p>
<p>虽然大部分Fragment的初始化并未有太大的消耗，但不排除一些特殊情况，比如在Fragment中进行例如new一个较大的数组这种操作。</p>
<h2 id="ViewPager及PagerAdapter实现类分析"><a href="#ViewPager及PagerAdapter实现类分析" class="headerlink" title="ViewPager及PagerAdapter实现类分析"></a>ViewPager及PagerAdapter实现类分析</h2><h3 id="ViewPager源码分析"><a href="#ViewPager源码分析" class="headerlink" title="ViewPager源码分析"></a>ViewPager源码分析</h3><hr>
<p>从ViewPager的setAdapter()方法看起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(<span class="meta">@Nullable</span> PagerAdapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果存在旧的Adapter,销毁旧的Adapter的数据</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAdapter.setViewPagerObserver(<span class="keyword">null</span>);</span><br><span class="line">            mAdapter.startUpdate(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//销毁旧Item的数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ItemInfo ii = mItems.get(i);</span><br><span class="line">                mAdapter.destroyItem(<span class="keyword">this</span>, ii.position, ii.object);</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapter.finishUpdate(<span class="keyword">this</span>);</span><br><span class="line">            mItems.clear();</span><br><span class="line">            removeNonDecorViews();</span><br><span class="line">            mCurItem = <span class="number">0</span>;</span><br><span class="line">            scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PagerAdapter oldAdapter = mAdapter;</span><br><span class="line">        mAdapter = adapter;</span><br><span class="line">        mExpectedAdapterCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mObserver == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mObserver = <span class="keyword">new</span> PagerObserver();</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapter.setViewPagerObserver(mObserver);</span><br><span class="line">            mPopulatePending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasFirstLayout = mFirstLayout;</span><br><span class="line">            mFirstLayout = <span class="keyword">true</span>;</span><br><span class="line">            mExpectedAdapterCount = mAdapter.getCount();</span><br><span class="line">            <span class="keyword">if</span> (mRestoredCurItem &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);</span><br><span class="line">                setCurrentItemInternal(mRestoredCurItem, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                mRestoredCurItem = -<span class="number">1</span>;</span><br><span class="line">                mRestoredAdapterState = <span class="keyword">null</span>;</span><br><span class="line">                mRestoredClassLoader = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasFirstLayout) &#123;</span><br><span class="line">                populate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//onMeasure()中也会调用populate()方法</span></span><br><span class="line">                requestLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch the change to any listeners</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterChangeListeners != <span class="keyword">null</span> &amp;&amp; !mAdapterChangeListeners.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = mAdapterChangeListeners.size(); i &lt; count; i++) &#123;</span><br><span class="line">                mAdapterChangeListeners.get(i).onAdapterChanged(<span class="keyword">this</span>, oldAdapter, adapter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下最终会调用populate()方法。</p>
<p>populate()方法主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">populate</span><span class="params">(<span class="keyword">int</span> newCurrentItem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//adapter页面将更改时调用</span></span><br><span class="line">    mAdapter.startUpdate(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mAdapter.getCount();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Locate the currently focused item or add it if needed.</span></span><br><span class="line">    <span class="keyword">int</span> curIndex = -<span class="number">1</span>;</span><br><span class="line">    ItemInfo curItem = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (curIndex = <span class="number">0</span>; curIndex &lt; mItems.size(); curIndex++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ItemInfo ii = mItems.get(curIndex);</span><br><span class="line">            <span class="keyword">if</span> (ii.position &gt;= mCurItem) &#123;</span><br><span class="line">                <span class="comment">//查到时</span></span><br><span class="line">                <span class="keyword">if</span> (ii.position == mCurItem) curItem = ii;</span><br><span class="line">               <span class="comment">//查找到或者往后不会再找到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//找不到当前需要的item,则add    </span></span><br><span class="line">    <span class="keyword">if</span> (curItem == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curItem = addNewItem(mCurItem, curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...两个循环对左右两边的Fragment进行缓存及清除(代码略)</span></span><br><span class="line">        </span><br><span class="line">    mAdapter.setPrimaryItem(<span class="keyword">this</span>, mCurItem, curItem.object);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemInfo</span> </span>&#123;</span><br><span class="line">        Object object;</span><br><span class="line">        <span class="keyword">int</span> position;</span><br><span class="line">        <span class="keyword">boolean</span> scrolling;</span><br><span class="line">        <span class="keyword">float</span> widthFactor;</span><br><span class="line">        <span class="keyword">float</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//存放缓存的Fragment</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; mItems = <span class="keyword">new</span> ArrayList&lt;ItemInfo&gt;();</span><br><span class="line">    <span class="keyword">int</span> mCurItem;   <span class="comment">// Index of currently displayed page.</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看addNewItem对应的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ItemInfo <span class="title">addNewItem</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       ItemInfo ii = <span class="keyword">new</span> ItemInfo();</span><br><span class="line">       ii.position = position;</span><br><span class="line">       ii.object = mAdapter.instantiateItem(<span class="keyword">this</span>, position);</span><br><span class="line">       ii.widthFactor = mAdapter.getPageWidth(position);</span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= mItems.size()) &#123;</span><br><span class="line">           mItems.add(ii);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mItems.add(index, ii);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ii;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了mAdapter.instantiateItem()方法，它的实现类是setAdapter()设置的PagerAdapter。接下来看一下PagerAdapter的两个实现类。</p>
<h3 id="直观感受两种PagerAdapter实现类的区别"><a href="#直观感受两种PagerAdapter实现类的区别" class="headerlink" title="直观感受两种PagerAdapter实现类的区别"></a>直观感受两种PagerAdapter实现类的区别</h3><hr>
<h4 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h4><hr>
<ul>
<li><p>适用于在固定的少量同级屏幕之间进行导航。</p>
</li>
<li><p>默认预加载当前Fragment及左右两个Fragment，若左边或右边无Fragment则不加载。</p>
<p><img src="https://i.loli.net/2021/10/15/BRjuCawQDktniX7.jpg" alt="IMG_0559.PNG"></p>
</li>
<li><blockquote>
<p>当前Fragment即为ViewPager中的CurrentItem,默认设置为0</p>
<p>默认加载的左右两个Fragment，是根据mOffscreenPageLimit计算出的，mOffscreenPageLimit默认为1，所以默认预加载左右各一个Fragment</p>
<p>本例均使用默认值</p>
</blockquote>
<p>在加载最左边，即第一个Fragment时，生命周期如下。</p>
<p>可见当前Fragment及其右边的Fragment都会执行到onResume()方法</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/10/11/4UV6ClNTWhGDnYr.png" alt="屏幕截图(229).png"></p>
<ul>
<li><p>当继续切换到第三个Fragment时，默认会缓存第二个Fragment和第四个Fragment，而刚开始已经加载过的Fragment生命周期会执行到onDestroyView(),并未执行onDestroy()方法，即Fragment的实例数据还存在，只是View被销毁了</p>
<p><img src="https://i.loli.net/2021/10/15/WBaQDzhiG9oLNpm.jpg" alt="IMG_0560.PNG"></p>
</li>
</ul>
<h4 id="FragmentStatePagerAdapter"><a href="#FragmentStatePagerAdapter" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h4><hr>
<ul>
<li><p>适用于对未知数量的页面进行分页。<code>FragmentStatePagerAdapter</code> 会在用户导航至其他位置时销毁 Fragment，从而优化内存使用情况</p>
</li>
<li><p>默认刚开始加载的Fragment的生命周期同上。</p>
</li>
<li><p>当切换到第三个Fragment时，最左边的Fragment会执行到onDetach()方法，即被销毁了。图略。</p>
</li>
</ul>
<h3 id="两种PagerAdapter实现类源码分析"><a href="#两种PagerAdapter实现类源码分析" class="headerlink" title="两种PagerAdapter实现类源码分析"></a>两种PagerAdapter实现类源码分析</h3><hr>
<h4 id="instantiateItem-方法"><a href="#instantiateItem-方法" class="headerlink" title="instantiateItem()方法"></a>instantiateItem()方法</h4><hr>
<h5 id="FragmentPagerAdapter-1"><a href="#FragmentPagerAdapter-1" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//根据position得到itemId,该方法默认返回position</span></span><br><span class="line">        <span class="keyword">long</span> itemId = <span class="keyword">this</span>.getItemId(position);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//生成tag,默认返回 &quot;android:switcher:&quot; + viewId + &quot;:&quot; + id</span></span><br><span class="line">        String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//根据tag到FragmentManager中寻找Fragment的实例</span></span><br><span class="line">        Fragment fragment = <span class="keyword">this</span>.mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//找到就调用attach方法</span></span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.attach(fragment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则调用getItem()获取Fragment实例，该方法是创建该FragmentPagerAdapter时会重			//写的</span></span><br><span class="line">            fragment = <span class="keyword">this</span>.getItem(position);</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断当前Fragment是否为获得焦点的当前Fragment</span></span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.STARTED);<span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">makeFragmentName</span><span class="params">(<span class="keyword">int</span> viewId, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;android:switcher:&quot;</span> + viewId + <span class="string">&quot;:&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>mBehavior的值默认为BEHAVIOR_SET_USER_VISIBLE_HINT，如果想要设置，可以在自定义的FragmentPagerAdapter的构造函数中调用super(fm,FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);</p>
</blockquote>
<p>注释1处，上述例子如果设置了mBehavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT，则该预加载的Fragment生命周期只会执行到onStart()，原因是调用了setMaxLifecycle()。该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到相应的状态。<a href="https://juejin.cn/post/6844904033774206984">详细可以看这篇博客</a></p>
<h5 id="FragmentStatePagerAdapter-1"><a href="#FragmentStatePagerAdapter-1" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SavedState是Fragment类里的，用于保存Bundle的信息</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;SavedState&gt; mSavedState;</span><br><span class="line"><span class="comment">//并非保存所有Fragment，而是保存根据mOffscreenPageLimit算出来的个数的Fragment</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Fragment&gt; mFragments;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Fragment fragment;</span><br><span class="line">    	<span class="comment">//先判断是否缓存了该Fragment，若有则直接复用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mFragments.size() &gt; position) &#123;</span><br><span class="line">            fragment = (Fragment)<span class="keyword">this</span>.mFragments.get(position);</span><br><span class="line">            <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> fragment;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//getItem是自行重写的方法</span></span><br><span class="line">        fragment = <span class="keyword">this</span>.getItem(position);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//查询是否保存有对应的Bundle信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mSavedState.size() &gt; position) &#123;</span><br><span class="line">            SavedState fss = (SavedState)<span class="keyword">this</span>.mSavedState.get(position);</span><br><span class="line">            <span class="keyword">if</span> (fss != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fragment.setInitialSavedState(fss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.mFragments.size() &lt;= position) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mFragments.add((Object)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == BEHAVIOR_SET_USER_VISIBLE_HINT) &#123;</span><br><span class="line">            fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//保存Fragment信息</span></span><br><span class="line">        <span class="keyword">this</span>.mFragments.set(position, fragment);</span><br><span class="line">        <span class="keyword">this</span>.mCurTransaction.add(container.getId(), fragment);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior ==  BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="destroyItem-方法"><a href="#destroyItem-方法" class="headerlink" title="destroyItem()方法"></a>destroyItem()方法</h4><h5 id="FragmentPagerAdapter-2"><a href="#FragmentPagerAdapter-2" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">       Fragment fragment = (Fragment)object;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	detach是从UI中将fragment的元素去掉，但是依然保留状态，</span></span><br><span class="line"><span class="comment">    	当调用attach的时候重新将之前的fragment连同状态一起恢复。 </span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">       <span class="keyword">this</span>.mCurTransaction.detach(fragment);</span><br><span class="line">       <span class="keyword">if</span> (fragment == <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurrentPrimaryItem = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="FragmentStatePagerAdapter-2"><a href="#FragmentStatePagerAdapter-2" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">       Fragment fragment = (Fragment)object;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">this</span>.mSavedState.size() &lt;= position) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mSavedState.add((Object)<span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.mSavedState.set(position, fragment.isAdded() ? <span class="keyword">this</span>.mFragmentManager.saveFragmentInstanceState(fragment) : <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">this</span>.mFragments.set(position, (Object)<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//remove是将fragment从UI中去掉，状态无法恢复了</span></span><br><span class="line">       <span class="keyword">this</span>.mCurTransaction.remove(fragment);</span><br><span class="line">       <span class="keyword">if</span> (fragment == <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurrentPrimaryItem = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过两个destroyItem()的实现可以发现，对fragment的不同销毁方法决定了fragment的生命周期。这也是为什么之前讲的，两种PagerAdapter对于超出预加载范围的Fragment的销毁，FragmentPagerAdapter对应的Fragment会执行到onDestroyView()方法，而FragmentStatePagerAdapter对应的Fragment会执行到onDetach()方法。</p>
<h4 id="setPrimaryItem-方法"><a href="#setPrimaryItem-方法" class="headerlink" title="setPrimaryItem()方法"></a>setPrimaryItem()方法</h4><hr>
<p>以上两个PagerAdapter的子类对其的实现是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//fragment是将要显示的Fragment，mCurrentPrimaryItem是目前正在显示的Fragment</span></span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">                    &#125;</span><br><span class="line">		<span class="comment">//将当前显示的Fragment的MaxLifecycle设置为STARTED。</span></span><br><span class="line">        <span class="comment">//即其生命周期从onResume回退到onStart</span></span><br><span class="line">                    <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(<span class="keyword">this</span>.mCurrentPrimaryItem, State.STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//将即将显示的Fragment的MaxLifecycle设置为RESUMED</span></span><br><span class="line">            <span class="comment">//所以该fragment生命周期从onStart变成onResume</span></span><br><span class="line">                <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.RESUMED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="预加载和懒加载"><a href="#预加载和懒加载" class="headerlink" title="预加载和懒加载"></a>预加载和懒加载</h2><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><hr>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><hr>
<p>  ViewPager的预加载机制会默认一次加载当前页面前后两个页面，预加载界面的个数可以自行设置。但至少会预加载前后各一个界面。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><hr>
<p>预加载在一定程度上可以保证切换界面时可以很快地见到加载完数据的完整界面，但其代价是，在不切换到别的界面时，别的界面会进行耗时的获取数据操作，这可能导致当前界面获取数据时发生卡顿。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><hr>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><hr>
<p>懒加载也可以叫做延迟加载，即当界面可见时再进行数据的加载。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><hr>
<p>懒加载可以通过对数据的延迟加载，解决因为预加载导致的性能降低的问题。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr>
<h5 id="传统处理方式"><a href="#传统处理方式" class="headerlink" title="传统处理方式"></a>传统处理方式</h5><hr>
<blockquote>
<ul>
<li><p>使用 ViewPager切换 Fragment 页面时（已经初始化完毕），只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</p>
</li>
<li><p>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当前Fragment是否可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isVisibleToUser = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//Fragment的View是否被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isViewCreated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否第一次加载数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstLoad = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="keyword">this</span>.isVisibleToUser = isVisibleToUser;</span><br><span class="line">        <span class="comment">//当setUserVisibleHint被回调时，会调用懒加载方法，这里其实可以进一步判断处理</span></span><br><span class="line">        <span class="comment">//如当可见时进行加载操作，不可见时停止加载</span></span><br><span class="line">        onLazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> View view, <span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        <span class="comment">//View创建成功</span></span><br><span class="line">        isViewCreated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这个函数被真正调用主要在于第一个Fragment加载的时候</span></span><br><span class="line">        <span class="comment">//因为最开始setUserVisibleHint执行时，view还未创建。</span></span><br><span class="line">        onLazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; isFirstLoad)&#123;</span><br><span class="line">            isFirstLoad = <span class="keyword">false</span>;</span><br><span class="line">            lazyLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//子类实现具体的加载逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Androidx-下的懒加载"><a href="#Androidx-下的懒加载" class="headerlink" title="Androidx 下的懒加载"></a>Androidx 下的懒加载</h5><hr>
<p>Google 在 Androidx 在 FragmentTransaction 中增加了 setMaxLifecycle 方法来控制 Fragment 所能调用的最大的生命周期函数。</p>
<p>该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 生命周期超过了设置的最大状态，那么会强制将 Fragment 降级到设置的状态。</p>
<p>结合之前讲的，可以在PagerAdapter子类的构造函数中调用super(fm,BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);来实现当前Fragment生命周期执行到onResume,预加载的Fragment生命周期执行到onStart,这样，就不会存在提前加载数据的情况了。</p>
<p>因此懒加载的方式变得更加简洁，不再需要多个标志位判断这样不优雅的代码实现懒加载的功能了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLifecycleFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isFirstLoad = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        <span class="keyword">if</span> (isFirstLoad) &#123;</span><br><span class="line">        	isFirstLoad = <span class="literal">false</span></span><br><span class="line">            loadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>预加载和懒加载都有一定的应用场景，在数据加载量少的时候不用懒加载也不会有很大的影响。</p>
<p>而懒加载的具体代码也可以根据具体的业务逻辑来确定，比如加载过数据的Fragment被destroyItem()方法处理后，再显示该Fragment的逻辑，因为从前面的分析可以知道具体的destroyItem()逻辑在不同PagerAdapter的实现类中是不一样的。</p>
<p>所以上面的代码只是最基础的代码逻辑参考，具体的逻辑可以在此基础上修改。</p>
<h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>ViewPager2 是 ViewPager 库的改进版本，可提供增强型功能并解决使用 ViewPager时遇到的一些常见问题。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><hr>
<ul>
<li><p>垂直方向支持</p>
</li>
<li><p>DiffUtil</p>
<blockquote>
<p>ViewPager2在 RecyclerView的基础上构建而成，这意味着它可以访问 DiffUtil 实用程序类。这一点带来了多项优势，但最突出的一项是，这意味着 ViewPager2 对象本身会利用 RecyclerView 类中的数据集更改动画</p>
</blockquote>
</li>
<li><p>可修改的 Fragment 集合</p>
<blockquote>
<p>ViewPager2 支持对可修改的 Fragment 集合进行分页浏览，在底层集合发生更改时调用 notifyDatasetChanged() 来更新界面。</p>
<p>这意味着，您的应用可以在运行时动态修改 Fragment 集合，而 ViewPager2 会正确显示修改后的集合。</p>
</blockquote>
</li>
</ul>
<h3 id="ViewPager迁移到-ViewPager2"><a href="#ViewPager迁移到-ViewPager2" class="headerlink" title="ViewPager迁移到 ViewPager2"></a>ViewPager迁移到 ViewPager2</h3><hr>
<h4 id="主要代码变化"><a href="#主要代码变化" class="headerlink" title="主要代码变化"></a>主要代码变化</h4><hr>
<ol>
<li>将父类更改为 RecyclerView.Adapter 用于分页浏览视图，或更改为 FragmentStateAdapter 用于分页浏览 Fragment。</li>
<li>更改基于 Fragment 的适配器类中的构造函数参数。</li>
<li>替换 <code>getItemCount()</code>，而不是 <code>getCount()</code>。</li>
<li>在基于 Fragment 的适配器类中，替换 createFragment()，而不是 getItem()。</li>
</ol>
<h4 id="若使用了TabLayout"><a href="#若使用了TabLayout" class="headerlink" title="若使用了TabLayout"></a>若使用了TabLayout</h4><hr>
<p> TabLayout 与 ViewPager 集成使用的是它自己的 setupWithViewPager() 方法，但是如果要与 ViewPager2 集成，却需要使用 TabLayoutMediator 实例。</p>
<p>TabLayoutMediator 对象还可处理为 TabLayout 对象生成页面标题的任务，这意味着相关适配器类不需要替换 getPageTitle()</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)</span><br><span class="line">TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt;</span><br><span class="line">    tab.text = <span class="string">&quot;OBJECT <span class="subst">$&#123;(position + <span class="number">1</span>)&#125;</span>&quot;</span></span><br><span class="line">&#125;.attach()</span><br></pre></td></tr></table></figure>



<h3 id="OffscreenPageLimit"><a href="#OffscreenPageLimit" class="headerlink" title="OffscreenPageLimit"></a>OffscreenPageLimit</h3><hr>
<p>查看相应的setOffscreenPageLimit()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OFFSCREEN_PAGE_LIMIT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@OffscreenPageLimit</span> <span class="keyword">int</span> mOffscreenPageLimit = OFFSCREEN_PAGE_LIMIT_DEFAULT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffscreenPageLimit</span><span class="params">(<span class="meta">@OffscreenPageLimit</span> <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (limit &lt; <span class="number">1</span> &amp;&amp; limit != OFFSCREEN_PAGE_LIMIT_DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;Offscreen page limit must be OFFSCREEN_PAGE_LIMIT_DEFAULT or a number &gt; 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mOffscreenPageLimit = limit;</span><br><span class="line">        <span class="comment">// Trigger layout so prefetch happens through getExtraLayoutSize()</span></span><br><span class="line">        mRecyclerView.requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewPager2的limit必须大于0或者为-1。limit的值不应该过大，尤其是在界面复杂的情况下。</p>
<p>limit的值默认设置为OFFSCREEN_PAGE_LIMIT_DEFAULT（即-1）。OFFSCREEN_PAGE_LIMIT_DEFAULT表示使用RecyclerView的默认缓存机制(刚开始只加载当前界面)，而不是显式地将页面预取并保留到当前页面的任一侧。</p>
<p>当加载第一个界面时，其对应加载的Fragment的生命周期如下<img src="https://i.loli.net/2021/10/13/LA7KSwpDPCihGMb.png" alt="屏幕截图(231).png"></p>
<p>当切换到下一个Fragment时，生命周期如下:</p>
<p>第一个Fragment的生命周期会到onPause()</p>
<p><img src="https://i.loli.net/2021/10/15/ezgFpdrPhQXcBis.png" alt="屏幕截图(233).png"></p>
<p>继续切换到下一个Fragment，生命周期如下。</p>
<p>可以发现，此时并不会对第一个Fragment进行销毁。</p>
<p><img src="https://i.loli.net/2021/10/15/2cfkJgrST4ma1uB.png" alt="屏幕截图(235).png"></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/1d95e729c571">关于RecyclerView的默认缓存机制和预取机制及其对Fragment的销毁情况可以看这个博客</a></p>
</blockquote>
<h3 id="懒加载-1"><a href="#懒加载-1" class="headerlink" title="懒加载"></a>懒加载</h3><hr>
<p>当通过setOffscreenPageLimit()设置了limit不为-1时，预加载的Fragment生命周期只执行到onStart()。显然是在FragmentStateAdapter中设置了MaxLifecycle，此时的懒加载方案和ViewPager在Androidx下的懒加载方案一致。</p>
<p>而当OffscreenPageLimit值为-1时，不存在预加载的情况，所以就不需要进行懒加载处理</p>
]]></content>
  </entry>
</search>
