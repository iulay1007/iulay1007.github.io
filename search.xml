<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言程序的内存分布和指针简介</title>
    <url>/2020/10/25/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="C语言程序的内存分布"><a href="#C语言程序的内存分布" class="headerlink" title="C语言程序的内存分布"></a>C语言程序的内存分布</h1><p><img src="https://i.loli.net/2020/10/23/b1fLa2u3EcBZSMG.jpg" alt="1364115879_7087.jpg"></p>
<a id="more"></a>

<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p><em>只读区域，程序运行过程中无法做任何修改的存储区域，用于存放CPU执行的机器指令</em></p>
<p>通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>代码区通常是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令。</p>
<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>包括已初始化的数据段(.data)和未初始化的数据段(.bss)</p>
<p><strong>已初始化的数据段</strong>：通常简称为数据段，是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。数据段中的静态数据区存放的是程序中已初始化的<strong>全局变量、静态变量和常量</strong>。</p>
<p><strong>未初始化的数据段</strong> ：亦称BSS区，存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0。</p>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>用于动态内存分配。</p>
<p>当进程调用malloc,calloc,realloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>由编译器自动分配释放内存的区间，所得的内存空间一般都是连续的，是用来存放函数的参数值、局部变量的值、函数的返回值等。</p>
<p>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>阅读代码，思考该程序的输出是什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(a, b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> t; </span><br><span class="line">     t = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><p>在计算机中，数据是存放在内存单元中的，一般把内存中的一个字节称为一个内存单元。为了更方便地访问这些内存单元，可预先给内存中的所有内存单元进行地址编号，根据地址编号，可准确找到其对应的内存单元。由于每一个地址编号均对应一个内存单元，因此可以形象地说一个地址编号就指向一个内存单元。C 语言中把地址形象地称作指针。</p>
<p>C语言中的每个变量均对应内存中的一块内存空间，而内存中每个内存单元均是有地址编号的。在 C 语言中，可以使用运算符 &amp; 求某个变量的地址。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		    <span class="keyword">char</span> c=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);<span class="comment">//输出变量a的值</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%x\n&quot;</span>,&amp;a);<span class="comment">//输出变量a的地址</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c=%x\n&quot;</span>,&amp;c);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某次运行的结果：</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">&amp;a=<span class="number">12f</span>f40</span><br><span class="line">c=A</span><br><span class="line">&amp;c=<span class="number">12f</span>f44</span><br></pre></td></tr></table></figure>

<p>区分<strong>变量的地址值</strong>和<strong>变量的值</strong>。如上例中，变量 a 的地址值（指针值）为12ff40，而变量 a 的值为 100。</p>
<p><img src="https://i.loli.net/2020/10/24/vhnxw4NeKoPQ5rW.jpg" alt="IMG_0037(20201024-223351).PNG"></p>
<p><img src="https://i.loli.net/2020/10/23/dXrR49sACthvVSz.png" alt="屏幕截图(52).png"></p>
<p>一个指针是一个地址，是一个常量。而一个指针变量却可以被赋予不同的指针值，是变量。但是常把指针变量简称为指针。为了避免混淆，我们约定：“指针” 是指地址，是常量，“指针变量”是指取值为地址的变量。</p>
<p>指针名、数组名、函数名就是地址，它们分别表示指针所指向元素的地址、数组的首地址和函数的入口地址</p>
<h4 id="指针变量的-定义格式-为："><a href="#指针变量的-定义格式-为：" class="headerlink" title="指针变量的 定义格式 为："></a>指针变量的 <strong>定义格式</strong> 为：</h4><p>数据类型符  * 变量名;  </p>
<p>如：    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; </span><br></pre></td></tr></table></figure>



<h4 id="指针变量初始化的方法："><a href="#指针变量初始化的方法：" class="headerlink" title="指针变量初始化的方法："></a>指针变量初始化的方法：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//&amp;为取址运算符，&amp;a即为取a的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// p指向a ，相当于*p就是a的别名</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 相当于 a = 10;</span></span><br></pre></td></tr></table></figure>



<h3 id="void-类型指针"><a href="#void-类型指针" class="headerlink" title="void*类型指针"></a>void*类型指针</h3><p>表示形式为 void*p;表示<strong>不指定 p 是指向哪一种数据类型的指针变量</strong>。使用时要进行强制类型转换。例如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2;  </span><br><span class="line"></span><br><span class="line">p1 = (<span class="keyword">char</span> *)p2;  </span><br><span class="line"></span><br><span class="line">p2 = (<span class="keyword">void</span> *)p1;</span><br></pre></td></tr></table></figure>



<h3 id="空指针NULL"><a href="#空指针NULL" class="headerlink" title="空指针NULL"></a>空指针NULL</h3><p>在C语言中，如果一个指针不指向任何数据，我们就称之为空指针，用NULL</p>
<p> 表示。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。</p>
<p>NULL 是一个宏定义，在stdio.h被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>



<p>我们知道，变量一旦定义就要分配内存，指针变量也是如此。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;  <span class="comment">//它不是空指针</span></span><br></pre></td></tr></table></figure>

<p>它的值是随机的，是垃圾值，如果不小心使用了它，运行时一般会引起段错误，导致程序退出，甚至会不知不觉地修改数据。</p>
<p><strong>所以，为了实现交换两个数的值的功能，可以将形参改为接收实参的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(&amp;a, &amp;b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc 与 free"></a>malloc 与 free</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><hr>
<p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void malloc(size_t size)</code></p>
<p><em>所以需要根据实际你需要的类型对其强制类型转换</em></p>
<p><strong>返回值</strong></p>
<p>成功时，返回指向新分配内存的指针。<br>失败时，返回空指针（NULL）</p>
<p><strong>参数：</strong>size : 要分配的字节数</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><hr>
<p><strong>头文件</strong>：<code>stdlib</code><br><strong>原型</strong>：<code>void free( void* ptr );</code><br><strong>参数</strong>：指向要解分配的内存的指针<br><strong>返回值</strong>：无</p>
<p>我们需要一个大小为 N ( N &lt; 1000)的数组,我们可能会想写成arr[N]，由输入决定数组的大小，但是这样写编译会出错。</p>
<p>所以我们通常这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的不确定可能会造成空间的浪费。</p>
<p>其实我们可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* arr &#x3D; (int*)malloc(sizeof(int) * N)</span><br></pre></td></tr></table></figure>

<p>该代码定义了一个指针arr指向sizeof(int) * N这么大的空间</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/02/hello-world/</url>
    <content><![CDATA[<p>We=lcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/29/Activity%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Activity的基本状态"><a href="#Activity的基本状态" class="headerlink" title="Activity的基本状态"></a>Activity的基本状态</h3><hr>
<h4 id="活动状态-running"><a href="#活动状态-running" class="headerlink" title="活动状态(running)"></a>活动状态(running)</h4><p>活动状态一般是指该Activity正处于屏幕最显著的位置上显示，即该Activity是在Android活动栈的最顶端。 此时它处于可见并可和用户交互的状态。</p>
<h4 id="暂停状态-paused"><a href="#暂停状态-paused" class="headerlink" title="暂停状态(paused)"></a><strong>暂停状态(paused)</strong></h4><p>暂停状态一般指该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。不可以触摸操作。失去焦点即被一个新的非全屏的Activity或者一个透明的Activity覆盖</p>
<a id="more"></a>

<h4 id="停止状态-stopped"><a href="#停止状态-stopped" class="headerlink" title="停止状态(stopped)"></a><strong>停止状态(stopped)</strong></h4><p>停止状态一般指该Activity被另一个Activity完全覆盖的状态</p>
<p>此状态下，该Activity的数据会暂时保留，但是，一旦系统需要内存，这种处于Stopped状态的Activity占用的空间会优先被清理并重新利用</p>
<h4 id="销毁状态-killed"><a href="#销毁状态-killed" class="headerlink" title="销毁状态(killed)"></a>销毁状态(killed)</h4><p>此时Activity已从Activity栈中移除，在内存中不存在</p>
<h3 id="Activity的状态转换"><a href="#Activity的状态转换" class="headerlink" title="Activity的状态转换"></a>Activity的状态转换</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/sfaq5YNBzuGKWvb.png" alt="屏幕截图(65).png"></p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/bUiop372zD6X8gx.png" alt="屏幕截图(63).png"></p>
<p><strong><em>onCreate ( )</em></strong>: 首次创建Activity时调用。进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。</p>
<p><strong><em>onStart ( )</em></strong> : 此时Activity已经<strong>可见</strong>了，但是还在后台，我们还看不到，无法与Activity交互。可以理解为Activity已经显示出来了，但是我们还看不见</p>
<p><strong><em>onResume ( )</em></strong> : Activity在这个阶段已经出现在前台并且<strong>可见</strong>了（处于running状态）。</p>
<p><strong><em>onPause ( )</em></strong> :表示暂停(paused状态），当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且Android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。</p>
<p><strong><em>onStop ( )</em></strong> :表示即将停止，此时Activity不可见。当Activity即将被销毁或被另一个Activity覆盖，则会调用onStop。如果新的Activity采用了透明主题，则不会回调onStop。这个阶段可以做一些微重量级的回收工作，同样不能太耗时。</p>
<p><strong><em>onDestroy ( )</em></strong> : Activity被销毁时调用。点击返回键或Activity里调用了finish方法或系统内存不足而选择强杀app时会调用onDestroy。在这里可以做一些回收工作和最终的资源释放。</p>
<p><strong><em>onRestart( )</em></strong> ：表示重新开始，Activity在这时<strong>可见</strong>，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。</p>
<p>从整个生命周期来说，onCreate和onDestroy是配对的，分别标识着Activity的创建和销毁，并且只会调用一次。</p>
<p>从Activity是否在前台来说，onResume和onPause是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<p>从Activity是否可见来说，onStart和onStop是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<h4 id="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"><a href="#打开一个app的MainActivity并跳转到另一个Activity时的生命周期" class="headerlink" title="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"></a>打开一个app的MainActivity并跳转到另一个Activity时的生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;某一个Activity第一次启动，回调为：onCreate-&gt;onStart-&gt;onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onResume</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳转到下一个Activity时</span><br><span class="line">当需要从MainActivity切换到SecondActivity时，先执行MainActivity中的与onResume()相对应的onPause()操作，比如关闭独占设备(比如相机），或其它耗费cpu的操作；</span><br><span class="line">以防SecondActivity也需要使用这些资源，关闭耗CPU的操作，也有利于SecondActivity运行的流畅。</span><br><span class="line"></span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onPause</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate"><a href="#为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate" class="headerlink" title="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?"></a>为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?</h4><p>从用户体验的角度来分析,当用户触发某事件切换到新的Activity，用户肯定是想尽快进入新的视图进行操作。<br>MainActivity中比较消耗资源的部分在onPause时关闭后，再切换到SecondActivity中执行SecondActivity<br>的初始化，显示SecondActivity中的View后，用户可以进行交互。</p>
<p>此时后台再去执行MainActivity的onStop()操作，即使这里面有些比较耗时的操作，也没有关系，这是在后台执行所以也不影响用户的体验。</p>
<h3 id="Activity的优先级"><a href="#Activity的优先级" class="headerlink" title="Activity的优先级"></a>Activity的优先级</h3><hr>
<p>从高到低：</p>
<p>(1)前台Activity——正在与用户交互的Activity，优先级最高</p>
<p>(2)可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但位于后台无法和用户直接交互</p>
<p>(3)后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低</p>
<p>当系统内存不足时，会按照上述优先级去杀死Activity所在进程。</p>
<h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><hr>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p><strong>标准模式</strong>：如果不设置Activity的启动模式，系统会默认将其设置为standard。</p>
<p>这种模式下，同一个Activity可以有多个实例，每次启动Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。</p>
<p><img src="https://i.loli.net/2020/11/29/bnKkBhFUXQwjSmY.png" alt="20180606100919308.png"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p><strong>栈顶复用模式</strong>：在这种模式下，如果新启动的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建。</p>
<p>如果新Activity的实例已存在但不位于栈顶，那么新Activity仍会重新创建。</p>
<p><img src="https://i.loli.net/2020/11/29/lUGdxmt6nOkog5X.png" alt="2.png"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p><strong>栈内复用模式</strong>：这是一种单实例模式，一个栈中同一个Activity只存在唯一一个实例，无论是否在栈顶，只要存在实例，都不会重新创建。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶。会导致任务栈内它上面的Activity被销毁。</p>
<p><img src="https://i.loli.net/2020/11/29/mOZjVPEzFMqaH3k.png" alt="3.png"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p><strong>单实例模式</strong>：这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是此种模式的Activity只能单独地位于一个任务栈中，不同的应用去打开这个Activity 共用同一个Activity。在该模式下，我们会为目标Activity创建一个新的任务栈，将目标Activity放入新的任务栈，由于栈内复用的特性，后续的请求不会创建新的Activity，除非这个独特的任务栈被系统销毁了。</p>
<p><img src="https://i.loli.net/2020/11/29/uxdQ1EsDAoCOfIt.png" alt="4.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/13/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Java中对象的访问方式"><a href="#Java中对象的访问方式" class="headerlink" title="Java中对象的访问方式"></a>Java中对象的访问方式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，<strong>并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置</strong>，所以对象访问方式也是<strong>取决于虚拟机实现的</strong>。目前主流的访问方式有使用<strong>句柄和直接指针</strong>两种</p>
<a id="more"></a>



<h3 id="使用句柄的访问方式"><a href="#使用句柄的访问方式" class="headerlink" title="使用句柄的访问方式"></a><strong>使用句柄的访问方式</strong></h3><hr>
<p>如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。对象实例数据一般在堆中开辟，类型数据一般储存在方法区中。</p>
<p><img src="https://i.loli.net/2021/03/12/NHmak9JWL5p3qzf.jpg" alt="1117609-20200327223929343-1244300162.jpg"></p>
<h3 id="使用直接指针的访问方式"><a href="#使用直接指针的访问方式" class="headerlink" title="使用直接指针的访问方式"></a>使用直接指针的访问方式</h3><hr>
<p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要在实例中存储</p>
<p><img src="https://i.loli.net/2021/03/12/7tOdcWXrkMUfhPT.jpg" alt="1117609-20200327223943696-1024093458.jpg"></p>
<h3 id="两种对象访问方式的区别"><a href="#两种对象访问方式的区别" class="headerlink" title="两种对象访问方式的区别"></a>两种对象访问方式的区别</h3><hr>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销， 由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。但它的缺点是，当对象被移动时（如进行GC后的内存重新排列），对象的引用（reference）也需要同步更新</p>
<h2 id="Java中的四大引用"><a href="#Java中的四大引用" class="headerlink" title="Java中的四大引用"></a>Java中的四大引用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    在很多时候，我们对于一个对象的存活时长要求是不一样的，这通常表现为我们希望的垃圾回收器对它的回收时机的不同。对于一些比较重要的对象，我们希望垃圾回收器永远不去回收它，即使此时内存空间已经不足了，因为一旦它被回收，将导致严重的后果。而对于一些不那么重要的对象，比如在做图片缓存的时候生成的大量图片的缓存对象，我们希望垃圾回收器只在内存不足的情况下去对它进行回收以提升用户体验</p>
<p>​    一般来说内存泄漏有两种情况。一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）；另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。第一种情况，在 Java 中已经由于垃圾回收机制的引入，得到了很好的解决。所以， Java 中的内存泄漏，主要指的是第二种情况。</p>
<p>​    而我们知道，在Java中垃圾回收器的运行是JVM操作的，但是我们仍然可以在一定程度上与垃圾回收器进行交互，其目的在于更好的帮助垃圾回收器管理好应用的内存。  从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><hr>
<p>强引用就是在程序代码普遍存在的例如Object object=new Object（）这类的引用；如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a><strong>软引用(Soft Reference)</strong></h3><hr>
<p>​    软引用用来描述一些有用但非必需的对象。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。**<em>就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收**</em>。</p>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a><strong>弱引用（Weak Reference）</strong></h3><hr>
<p>​    弱引用也用来描述非必需的对象。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，被弱引用关联的对象只能生存到下一次垃圾收集发生前。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a><strong>虚引用（Phantom Reference）</strong></h3><hr>
<p>​      “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会影响与之关联的对象的生存时间，也无法通过虚引用来取得一个对象的实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，<strong>来了解被引用的对象是否将要被垃圾回收，即在这个对象被回收时可以得到通知</strong>。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(  <span class="string">&quot; hello &quot;</span> );</span><br><span class="line">     ReferenceQueue&lt; String &gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue &lt; String &gt; ();</span><br><span class="line">     <span class="comment">//SoftReference&lt; String &gt; reference = new SoftReference &lt; String &gt; (str, referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     无论是否调用System.gc()，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     一个对象只具有软引用，内存不足时才回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     WeakReference&lt; String &gt; reference = <span class="keyword">new</span> WeakReference &lt; String &gt; (str, 		referenceQueue);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有进行垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     进行垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.WeakReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象只具有弱引用，在垃圾回收器线程扫描它所管辖的内存区域的过程中，</span></span><br><span class="line"><span class="comment">     一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//PhantomReference&lt;String&gt; reference = new PhantomReference&lt;String&gt;(str,referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有被垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     被垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.PhantomReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象仅持有虚引用，那么它就和没有任何引用一样，</span></span><br><span class="line"><span class="comment">     在任何时候都可能被垃圾回收*/</span></span><br><span class="line"></span><br><span class="line">     str = <span class="keyword">null</span> ;  <span class="comment">// 取消&quot;hello&quot;对象的强引用</span></span><br><span class="line">     System.gc();</span><br><span class="line">     String str1 = reference.get();</span><br><span class="line">     System.out.println(str1);</span><br><span class="line">     System.out.println(referenceQueue.poll());</span><br></pre></td></tr></table></figure>



<p>如图，“hello”对象同时具有强引用和弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/g73ROq9vGZMpzdh.png" alt="6ae1becb-74c0-3c51-9602-9a2d7cf7dbf9.png"></p>
<p>当str为null，“hello”对象不再具有强引用，而只具有弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/CbEAo3MBj5Fmi1e.png" alt="aad88dc6-7d9e-30da-a705-c66cf94bfa46.png"></p>
<h3 id="引用的区别与选择"><a href="#引用的区别与选择" class="headerlink" title="引用的区别与选择"></a>引用的区别与选择</h3><hr>
<p><img src="https://i.loli.net/2021/03/11/OLu2gwoP46xBsNE.png" alt="屏幕截图(149).png"></p>
<ul>
<li><p>SoftReference 具有构建 Cache 系统的特质，因此我们可以结合哈希表实现一个简单的缓存系统。这样既能保证能够尽可能多的缓存信息，又可以保证 Java虚拟机不会因为内存泄露而抛出  OutOfMemoryError  。这种缓存机制特别适合于内存对象生命周期长，且生成内存对象的耗时比较长的情况，例如缓存列表封面图片等。对于一些生命周期较长，但是生成内存对象开销不大的情况，使用WeakReference 能够达到更好的内存管理的效果。 </p>
</li>
<li><p>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用</p>
</li>
</ul>
<h3 id="Handler-可能引起的内存泄漏"><a href="#Handler-可能引起的内存泄漏" class="headerlink" title="Handler 可能引起的内存泄漏"></a>Handler 可能引起的内存泄漏</h3><hr>
<p>我们经常会写这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>当你这样写的时候，你一定会收到编译器的黄色警告。</p>
<blockquote>
<p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p>
</blockquote>
<p><strong>在 Java 中，非静态的内部类和匿名内部类都会 <em>隐式地</em>  持有其外部类的引用</strong>。由于Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也不可能被释放，当一个对象已经不需要再使用了，本来该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</p>
<p>要解决这样的问题，我们在继承 <code>Handler</code> 的时候，要么是放在单独的类文件中，要么直接使用静态内部类，静态的内部类不会持有外部类的引用。当需要在静态内部类中调用外部的 Activity 的时候，我们可以直接采用<strong>弱引用</strong>进行处理，所以我们大概修改后的代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span></span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            MainActivity activity = mWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始写业务代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> MyHandler mMyHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>其实在我们实际开发中，不止一个地方可能会用到内部类，我们都需要在这样的情况下尽量使用静态内部类加弱引用的方式解决我们可能出现的内存泄漏问题。</p>
]]></content>
  </entry>
</search>
