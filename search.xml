<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity的基本状态</title>
    <url>/2020/11/29/Activity%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="活动状态-running"><a href="#活动状态-running" class="headerlink" title="活动状态(running)"></a>活动状态(running)</h4><p>活动状态一般是指该Activity正处于屏幕最显著的位置上显示，即该Activity是在Android活动栈的最顶端。 此时它处于可见并可和用户交互的状态。</p>
<h4 id="暂停状态-paused"><a href="#暂停状态-paused" class="headerlink" title="暂停状态(paused)"></a><strong>暂停状态(paused)</strong></h4><p>暂停状态一般指该Activity已失去了焦点但仍然是可见的状态(包括部分可见)。不可以触摸操作。失去焦点即被一个新的非全屏的Activity或者一个透明的Activity覆盖</p>
<a id="more"></a>

<h4 id="停止状态-stopped"><a href="#停止状态-stopped" class="headerlink" title="停止状态(stopped)"></a><strong>停止状态(stopped)</strong></h4><p>停止状态一般指该Activity被另一个Activity完全覆盖的状态</p>
<p>此状态下，该Activity的数据会暂时保留，但是，一旦系统需要内存，这种处于Stopped状态的Activity占用的空间会优先被清理并重新利用</p>
<h4 id="销毁状态-killed"><a href="#销毁状态-killed" class="headerlink" title="销毁状态(killed)"></a>销毁状态(killed)</h4><p>此时Activity已从Activity栈中移除，在内存中不存在</p>
<h3 id="Activity的状态转换"><a href="#Activity的状态转换" class="headerlink" title="Activity的状态转换"></a>Activity的状态转换</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/sfaq5YNBzuGKWvb.png" alt="屏幕截图(65).png"></p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><hr>
<p><img src="https://i.loli.net/2020/11/27/bUiop372zD6X8gx.png" alt="屏幕截图(63).png"></p>
<p><strong><em>onCreate ( )</em></strong>: 首次创建Activity时调用。进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。</p>
<p><strong><em>onStart ( )</em></strong> : 此时Activity已经<strong>可见</strong>了，但是还在后台，我们还看不到，无法与Activity交互。可以理解为Activity已经显示出来了，但是我们还看不见</p>
<p><strong><em>onResume ( )</em></strong> : Activity在这个阶段已经出现在前台并且<strong>可见</strong>了（处于running状态）。</p>
<p><strong><em>onPause ( )</em></strong> :表示暂停(paused状态），当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且Android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。</p>
<p><strong><em>onStop ( )</em></strong> :表示即将停止，此时Activity不可见。当Activity即将被销毁或被另一个Activity覆盖，则会调用onStop。如果新的Activity采用了透明主题，则不会回调onStop。这个阶段可以做一些微重量级的回收工作，同样不能太耗时。</p>
<p><strong><em>onDestroy ( )</em></strong> : Activity被销毁时调用。点击返回键或Activity里调用了finish方法或系统内存不足而选择强杀app时会调用onDestroy。在这里可以做一些回收工作和最终的资源释放。</p>
<p><strong><em>onRestart( )</em></strong> ：表示重新开始，Activity在这时<strong>可见</strong>，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。</p>
<p>从整个生命周期来说，onCreate和onDestroy是配对的，分别标识着Activity的创建和销毁，并且只会调用一次。</p>
<p>从Activity是否在前台来说，onResume和onPause是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<p>从Activity是否可见来说，onStart和onStop是配对的，随着用户的操作或设备屏幕的点亮和熄灭，这两个方法可以被多次调用。</p>
<h4 id="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"><a href="#打开一个app的MainActivity并跳转到另一个Activity时的生命周期" class="headerlink" title="打开一个app的MainActivity并跳转到另一个Activity时的生命周期"></a>打开一个app的MainActivity并跳转到另一个Activity时的生命周期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;某一个Activity第一次启动，回调为：onCreate-&gt;onStart-&gt;onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onResume</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳转到下一个Activity时</span><br><span class="line">当需要从MainActivity切换到SecondActivity时，先执行MainActivity中的与onResume()相对应的onPause()操作，比如关闭独占设备(比如相机），或其它耗费cpu的操作；</span><br><span class="line">以防SecondActivity也需要使用这些资源，关闭耗CPU的操作，也有利于SecondActivity运行的流畅。</span><br><span class="line"></span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onPause</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onCreate</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onStart</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.SecondActivity :onResume</span><br><span class="line">&#x2F;com.example.activitytest I&#x2F;.MainActivity :onStop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate"><a href="#为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate" class="headerlink" title="为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?"></a>为什么不先执行MainActivity的onStop再执行SecondActivity的onCreate?</h4><p>从用户体验的角度来分析,当用户触发某事件切换到新的Activity，用户肯定是想尽快进入新的视图进行操作。<br>MainActivity中比较消耗资源的部分在onPause时关闭后，再切换到SecondActivity中执行SecondActivity<br>的初始化，显示SecondActivity中的View后，用户可以进行交互。</p>
<p>此时后台再去执行MainActivity的onStop()操作，即使这里面有些比较耗时的操作，也没有关系，这是在后台执行所以也不影响用户的体验。</p>
<h3 id="Activity的优先级"><a href="#Activity的优先级" class="headerlink" title="Activity的优先级"></a>Activity的优先级</h3><hr>
<p>从高到低：</p>
<p>(1)前台Activity——正在与用户交互的Activity，优先级最高</p>
<p>(2)可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但位于后台无法和用户直接交互</p>
<p>(3)后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低</p>
<p>当系统内存不足时，会按照上述优先级去杀死Activity所在进程。</p>
<h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><hr>
<h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p><strong>标准模式</strong>：如果不设置Activity的启动模式，系统会默认将其设置为standard。</p>
<p>这种模式下，同一个Activity可以有多个实例，每次启动Activity，无论任务栈中是否已经有这个Activity的实例，系统都会创建一个新的Activity实例。</p>
<p><img src="https://i.loli.net/2020/11/29/bnKkBhFUXQwjSmY.png" alt="20180606100919308.png"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p><strong>栈顶复用模式</strong>：在这种模式下，如果新启动的Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建。</p>
<p>如果新Activity的实例已存在但不位于栈顶，那么新Activity仍会重新创建。</p>
<p><img src="https://i.loli.net/2020/11/29/lUGdxmt6nOkog5X.png" alt="2.png"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p><strong>栈内复用模式</strong>：这是一种单实例模式，一个栈中同一个Activity只存在唯一一个实例，无论是否在栈顶，只要存在实例，都不会重新创建。但Activity已经存在但不位于栈顶时，系统就会把该Activity移到栈顶。会导致任务栈内它上面的Activity被销毁。</p>
<p><img src="https://i.loli.net/2020/11/29/mOZjVPEzFMqaH3k.png" alt="3.png"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p><strong>单实例模式</strong>：这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是此种模式的Activity只能单独地位于一个任务栈中，不同的应用去打开这个Activity 共用同一个Activity。在该模式下，我们会为目标Activity创建一个新的任务栈，将目标Activity放入新的任务栈，由于栈内复用的特性，后续的请求不会创建新的Activity，除非这个独特的任务栈被系统销毁了。</p>
<p><img src="https://i.loli.net/2020/11/29/uxdQ1EsDAoCOfIt.png" alt="4.png"></p>
]]></content>
  </entry>
  <entry>
    <title>C语言程序的内存分布和指针简介</title>
    <url>/2020/10/25/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%92%8C%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="C语言程序的内存分布"><a href="#C语言程序的内存分布" class="headerlink" title="C语言程序的内存分布"></a>C语言程序的内存分布</h1><p><img src="https://i.loli.net/2020/10/23/b1fLa2u3EcBZSMG.jpg" alt="1364115879_7087.jpg"></p>
<a id="more"></a>

<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p><em>只读区域，程序运行过程中无法做任何修改的存储区域，用于存放CPU执行的机器指令</em></p>
<p>通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>代码区通常是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令。</p>
<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>包括已初始化的数据段(.data)和未初始化的数据段(.bss)</p>
<p><strong>已初始化的数据段</strong>：通常简称为数据段，是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。数据段中的静态数据区存放的是程序中已初始化的<strong>全局变量、静态变量和常量</strong>。</p>
<p><strong>未初始化的数据段</strong> ：亦称BSS区，存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0。</p>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>用于动态内存分配。</p>
<p>当进程调用malloc,calloc,realloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>由编译器自动分配释放内存的区间，所得的内存空间一般都是连续的，是用来存放函数的参数值、局部变量的值、函数的返回值等。</p>
<p>在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>阅读代码，思考该程序的输出是什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(a, b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> t; </span><br><span class="line">     t = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存与地址"><a href="#内存与地址" class="headerlink" title="内存与地址"></a>内存与地址</h3><p>在计算机中，数据是存放在内存单元中的，一般把内存中的一个字节称为一个内存单元。为了更方便地访问这些内存单元，可预先给内存中的所有内存单元进行地址编号，根据地址编号，可准确找到其对应的内存单元。由于每一个地址编号均对应一个内存单元，因此可以形象地说一个地址编号就指向一个内存单元。C 语言中把地址形象地称作指针。</p>
<p>C语言中的每个变量均对应内存中的一块内存空间，而内存中每个内存单元均是有地址编号的。在 C 语言中，可以使用运算符 &amp; 求某个变量的地址。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		    <span class="keyword">char</span> c=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);<span class="comment">//输出变量a的值</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%x\n&quot;</span>,&amp;a);<span class="comment">//输出变量a的地址</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;c=%c\n&quot;</span>,c);</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;&amp;c=%x\n&quot;</span>,&amp;c);</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//某次运行的结果：</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">&amp;a=<span class="number">12f</span>f40</span><br><span class="line">c=A</span><br><span class="line">&amp;c=<span class="number">12f</span>f44</span><br></pre></td></tr></table></figure>

<p>区分<strong>变量的地址值</strong>和<strong>变量的值</strong>。如上例中，变量 a 的地址值（指针值）为12ff40，而变量 a 的值为 100。</p>
<p><img src="https://i.loli.net/2020/10/24/vhnxw4NeKoPQ5rW.jpg" alt="IMG_0037(20201024-223351).PNG"></p>
<p><img src="https://i.loli.net/2020/10/23/dXrR49sACthvVSz.png" alt="屏幕截图(52).png"></p>
<p>一个指针是一个地址，是一个常量。而一个指针变量却可以被赋予不同的指针值，是变量。但是常把指针变量简称为指针。为了避免混淆，我们约定：“指针” 是指地址，是常量，“指针变量”是指取值为地址的变量。</p>
<p>指针名、数组名、函数名就是地址，它们分别表示指针所指向元素的地址、数组的首地址和函数的入口地址</p>
<h4 id="指针变量的-定义格式-为："><a href="#指针变量的-定义格式-为：" class="headerlink" title="指针变量的 定义格式 为："></a>指针变量的 <strong>定义格式</strong> 为：</h4><p>数据类型符  * 变量名;  </p>
<p>如：    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; </span><br></pre></td></tr></table></figure>



<h4 id="指针变量初始化的方法："><a href="#指针变量初始化的方法：" class="headerlink" title="指针变量初始化的方法："></a>指针变量初始化的方法：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">//&amp;为取址运算符，&amp;a即为取a的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="引用指针变量"><a href="#引用指针变量" class="headerlink" title="引用指针变量"></a>引用指针变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a; <span class="comment">// p指向a ，相当于*p就是a的别名</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">// 相当于 a = 10;</span></span><br></pre></td></tr></table></figure>



<h3 id="void-类型指针"><a href="#void-类型指针" class="headerlink" title="void*类型指针"></a>void*类型指针</h3><p>表示形式为 void*p;表示<strong>不指定 p 是指向哪一种数据类型的指针变量</strong>。使用时要进行强制类型转换。例如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p2;  </span><br><span class="line"></span><br><span class="line">p1 = (<span class="keyword">char</span> *)p2;  </span><br><span class="line"></span><br><span class="line">p2 = (<span class="keyword">void</span> *)p1;</span><br></pre></td></tr></table></figure>



<h3 id="空指针NULL"><a href="#空指针NULL" class="headerlink" title="空指针NULL"></a>空指针NULL</h3><p>在C语言中，如果一个指针不指向任何数据，我们就称之为空指针，用NULL</p>
<p> 表示。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。</p>
<p>NULL 是一个宏定义，在stdio.h被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>



<p>我们知道，变量一旦定义就要分配内存，指针变量也是如此。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;  <span class="comment">//它不是空指针</span></span><br></pre></td></tr></table></figure>

<p>它的值是随机的，是垃圾值，如果不小心使用了它，运行时一般会引起段错误，导致程序退出，甚至会不知不觉地修改数据。</p>
<p><strong>所以，为了实现交换两个数的值的功能，可以将形参改为接收实参的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      swap(&amp;a, &amp;b);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="malloc-与-free"><a href="#malloc-与-free" class="headerlink" title="malloc 与 free"></a>malloc 与 free</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><hr>
<p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void malloc(size_t size)</code></p>
<p><em>所以需要根据实际你需要的类型对其强制类型转换</em></p>
<p><strong>返回值</strong></p>
<p>成功时，返回指向新分配内存的指针。<br>失败时，返回空指针（NULL）</p>
<p><strong>参数：</strong>size : 要分配的字节数</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><hr>
<p><strong>头文件</strong>：<code>stdlib</code><br><strong>原型</strong>：<code>void free( void* ptr );</code><br><strong>参数</strong>：指向要解分配的内存的指针<br><strong>返回值</strong>：无</p>
<p>我们需要一个大小为 N ( N &lt; 1000)的数组,我们可能会想写成arr[N]，由输入决定数组的大小，但是这样写编译会出错。</p>
<p>所以我们通常这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入%d个数\n&quot;</span>, N);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的不确定可能会造成空间的浪费。</p>
<p>其实我们可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* arr &#x3D; (int*)malloc(sizeof(int) * N)</span><br></pre></td></tr></table></figure>

<p>该代码定义了一个指针arr指向sizeof(int) * N这么大的空间</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler</title>
    <url>/2021/03/27/Handler/</url>
    <content><![CDATA[<h3 id="为什么需要Handler"><a href="#为什么需要Handler" class="headerlink" title="为什么需要Handler"></a>为什么需要Handler</h3><hr>
<p>Handler的主要作用是将一个任务切换到某个指定的指定的线程中执行。而Handler常常可以用于在子线程更新UI。</p>
<p>系统为什么不允许在子线程更新UI呢？这是因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态。那么为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂；其次，锁机制会降低UI的访问效率，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换一下UI访问的执行线程即可。</p>
<a id="more"></a>



<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>Handler运行需要底层的MessageQueue和Looper支撑。其中MessageQueue采用的是单链表的结构，Looper可以叫做消息循环。由于MessageQueue只是一个消息存储单元，不能去处理消息，而Looper就是专门来处理消息的，Looper会以无限循环的形式去查找是否有新消息，如果有的话，就处理，否则就一直等待着。</p>
<p>当Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。注意Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。</p>
<p>我们知道，Handler创建的时候会采用 <strong><em>当前线程</em></strong> 的Looper来构造消息循环系统，需要注意的是，线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper，因为默认的UI主线程，也就是ActivityThread，ActivityThread被创建的时候就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><blockquote>
<p>定义：是线程间通讯的数据单元，包含着描述信息及任意数据对象，发送到 Handler。</p>
</blockquote>
<p>在实际使用中，我们在工作线程中通过 Handler.sendMessage(Message)，将携带数据的 Message 信息发送给 Handler，然后再由 Handler 处理，根据不同的信息，通知主线程作出相对应的 UI 工作。</p>
<h4 id="MessageQueue-消息队列"><a href="#MessageQueue-消息队列" class="headerlink" title="MessageQueue 消息队列"></a>MessageQueue 消息队列</h4><blockquote>
<p>定义：用来存储 Message 的数据队列。</p>
</blockquote>
<p>主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作。插入对应的方法为enqueueMessage，读取对应的方法为next。next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next会返回这条消息并将其从单链表中移除。</p>
<h4 id="Looper-消息循环器"><a href="#Looper-消息循环器" class="headerlink" title="Looper 消息循环器"></a>Looper 消息循环器</h4><blockquote>
<p>定义：用于为线程执行消息循环的一个类。是 MessageQueue 与 Handler 之间的通讯媒介。</p>
</blockquote>
<p>会不停地从MessageQueue中查看是否有新消息，如果有新消息就立即处理，否则就一直阻塞在那里。</p>
<p>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待状态。而**如果退出Looper以后，这个线程就会立刻终止 **。因此建议在不需要的时候终止Looper</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="https://i.loli.net/2021/03/27/n4dvK1o3k8MgyPH.png" alt="20200104121245311.png"></p>
<p>存储在 <strong>MessageQueue</strong> 中的 <strong>Message</strong> 被 <strong>Looper</strong> 循环分发到指定的 <strong>Handler</strong> 中进行处理</p>
<ul>
<li>一个 Thread 可以有多个 Handler。</li>
<li>但一个 Thread 只能有一个 Looper，即在该线程调用Looper.prepare()创建的Looper</li>
<li>一个 Handler 只能关联一个 Looper 对象，即创建Handler线程的Looper</li>
<li>反之，一个 Looper 可以被多个 Handler 所关联</li>
<li>一个Looper创建一个MessageQueue</li>
</ul>
<h3 id="Handler的构造方法"><a href="#Handler的构造方法" class="headerlink" title="Handler的构造方法"></a>Handler的构造方法</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h3><hr>
<h4 id="1-新建Handler子类（内部类）"><a href="#1-新建Handler子类（内部类）" class="headerlink" title="1.新建Handler子类（内部类）"></a>1.新建Handler子类（内部类）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：（自定义）新创建Handler子类(继承Handler类) &amp; 复写handleMessage（）方法</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mhandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据不同线程发送过来的消息，执行不同的UI操作</span></span><br><span class="line">            <span class="comment">// 根据 Message对象的what属性 标识不同的消息</span></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Mhandler();</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用2个工作线程展示</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过sendMessage（）发送</span></span><br><span class="line">                 <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">                 <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 根据不同线程发送过来的消息，执行不同的UI操作</span></span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">                 Message msg = Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-Handler-post（Runnable）"><a href="#3-Handler-post（Runnable）" class="headerlink" title="3.Handler.post（Runnable）"></a>3.Handler.post（Runnable）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过psot（）发送，需传入1个Runnable对象</span></span><br><span class="line">                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 指定操作UI内容</span></span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>先看一下sendMessage的源码分析一下执行过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">           Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现，Handler发送消息的过程仅仅是向消息队列插入了一条消息（调用MessageQueue的enqueueMessage方法）。MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理，最终交由Handler处理。即Handler的dispatchMessage方法被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handleCallback(msg);</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          handleMessage(msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Handler处理消息的过程如下：</p>
<p>首先，检查Message的callback（msg.callback）是否为null，不为null就通过handleCallback来处理消息。这里的msg.callback即为Handler的post方法传进来的Runnable对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.obj = token;</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>其次检查mCallback是否为null。不为null就调用mCallback的HandleMessage方法来处理消息。Callback是个接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>通过Callback可以通过Handler handler=new Handler(callback)来创建Handler对象。其作用在于可以用来创建Handler实例而不需要派生Handler的子类</p>
<p>最后调用Handler的handleMessage方法来处理消息。handleMessage方法是Handler子类需要实现的。</p>
<h3 id="子线程创建Handler"><a href="#子线程创建Handler" class="headerlink" title="子线程创建Handler"></a>子线程创建Handler</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomChildThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//为当前线程创建一个 Looper 对象</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//在子线程中创建一个 Handler 对象</span></span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 在这里处理传入的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//开始消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/02/hello-world/</url>
    <content><![CDATA[<p>We=lcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>对象访问方式及四大引用</title>
    <url>/2021/03/13/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Java中对象的访问方式"><a href="#Java中对象的访问方式" class="headerlink" title="Java中对象的访问方式"></a>Java中对象的访问方式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，<strong>并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置</strong>，所以对象访问方式也是<strong>取决于虚拟机实现的</strong>。目前主流的访问方式有使用<strong>句柄和直接指针</strong>两种</p>
<a id="more"></a>



<h3 id="使用句柄的访问方式"><a href="#使用句柄的访问方式" class="headerlink" title="使用句柄的访问方式"></a><strong>使用句柄的访问方式</strong></h3><hr>
<p>如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。对象实例数据一般在堆中开辟，类型数据一般储存在方法区中。</p>
<p><img src="https://i.loli.net/2021/03/12/NHmak9JWL5p3qzf.jpg" alt="1117609-20200327223929343-1244300162.jpg"></p>
<h3 id="使用直接指针的访问方式"><a href="#使用直接指针的访问方式" class="headerlink" title="使用直接指针的访问方式"></a>使用直接指针的访问方式</h3><hr>
<p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要在实例中存储</p>
<p><img src="https://i.loli.net/2021/03/12/7tOdcWXrkMUfhPT.jpg" alt="1117609-20200327223943696-1024093458.jpg"></p>
<h3 id="两种对象访问方式的区别"><a href="#两种对象访问方式的区别" class="headerlink" title="两种对象访问方式的区别"></a>两种对象访问方式的区别</h3><hr>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销， 由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。但它的缺点是，当对象被移动时（如进行GC后的内存重新排列），对象的引用（reference）也需要同步更新</p>
<h2 id="Java中的四大引用"><a href="#Java中的四大引用" class="headerlink" title="Java中的四大引用"></a>Java中的四大引用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​    在很多时候，我们对于一个对象的存活时长要求是不一样的，这通常表现为我们希望的垃圾回收器对它的回收时机的不同。对于一些比较重要的对象，我们希望垃圾回收器永远不去回收它，即使此时内存空间已经不足了，因为一旦它被回收，将导致严重的后果。而对于一些不那么重要的对象，比如在做图片缓存的时候生成的大量图片的缓存对象，我们希望垃圾回收器只在内存不足的情况下去对它进行回收以提升用户体验</p>
<p>​    一般来说内存泄漏有两种情况。一种情况如在C/C++ 语言中的，在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值）；另一种情况则是在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用）。第一种情况，在 Java 中已经由于垃圾回收机制的引入，得到了很好的解决。所以， Java 中的内存泄漏，主要指的是第二种情况。</p>
<p>​    而我们知道，在Java中垃圾回收器的运行是JVM操作的，但是我们仍然可以在一定程度上与垃圾回收器进行交互，其目的在于更好的帮助垃圾回收器管理好应用的内存。  从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><hr>
<p>强引用就是在程序代码普遍存在的例如Object object=new Object（）这类的引用；如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a><strong>软引用(Soft Reference)</strong></h3><hr>
<p>​    软引用用来描述一些有用但非必需的对象。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>软引用对象是在jvm内存不够的时候才会被回收，我们调用System.gc()方法只是起通知作用，JVM什么时候扫描回收对象是JVM自己的状态决定的。**<em>就算扫描到软引用对象也不一定会回收它，只有内存不够的时候才会回收**</em>。</p>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a><strong>弱引用（Weak Reference）</strong></h3><hr>
<p>​    弱引用也用来描述非必需的对象。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期，被弱引用关联的对象只能生存到下一次垃圾收集发生前。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 </p>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a><strong>虚引用（Phantom Reference）</strong></h3><hr>
<p>​      “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会影响与之关联的对象的生存时间，也无法通过虚引用来取得一个对象的实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，<strong>来了解被引用的对象是否将要被垃圾回收，即在这个对象被回收时可以得到通知</strong>。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(  <span class="string">&quot; hello &quot;</span> );</span><br><span class="line">     ReferenceQueue&lt; String &gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue &lt; String &gt; ();</span><br><span class="line">     <span class="comment">//SoftReference&lt; String &gt; reference = new SoftReference &lt; String &gt; (str, referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     无论是否调用System.gc()，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     一个对象只具有软引用，内存不足时才回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     WeakReference&lt; String &gt; reference = <span class="keyword">new</span> WeakReference &lt; String &gt; (str, 		referenceQueue);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有进行垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     hello</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     进行垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.WeakReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象只具有弱引用，在垃圾回收器线程扫描它所管辖的内存区域的过程中，</span></span><br><span class="line"><span class="comment">     一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//PhantomReference&lt;String&gt; reference = new PhantomReference&lt;String&gt;(str,referenceQueue);</span></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     没有被垃圾回收时，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     被垃圾回收后，输出为</span></span><br><span class="line"><span class="comment">     null</span></span><br><span class="line"><span class="comment">     java.lang.ref.PhantomReference@1b6d3586</span></span><br><span class="line"><span class="comment">     一个对象仅持有虚引用，那么它就和没有任何引用一样，</span></span><br><span class="line"><span class="comment">     在任何时候都可能被垃圾回收*/</span></span><br><span class="line"></span><br><span class="line">     str = <span class="keyword">null</span> ;  <span class="comment">// 取消&quot;hello&quot;对象的强引用</span></span><br><span class="line">     System.gc();</span><br><span class="line">     String str1 = reference.get();</span><br><span class="line">     System.out.println(str1);</span><br><span class="line">     System.out.println(referenceQueue.poll());</span><br></pre></td></tr></table></figure>



<p>如图，“hello”对象同时具有强引用和弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/g73ROq9vGZMpzdh.png" alt="6ae1becb-74c0-3c51-9602-9a2d7cf7dbf9.png"></p>
<p>当str为null，“hello”对象不再具有强引用，而只具有弱引用</p>
<p><img src="https://i.loli.net/2021/03/11/CbEAo3MBj5Fmi1e.png" alt="aad88dc6-7d9e-30da-a705-c66cf94bfa46.png"></p>
<h3 id="引用的区别与选择"><a href="#引用的区别与选择" class="headerlink" title="引用的区别与选择"></a>引用的区别与选择</h3><hr>
<p><img src="https://i.loli.net/2021/03/11/OLu2gwoP46xBsNE.png" alt="屏幕截图(149).png"></p>
<ul>
<li><p>SoftReference 具有构建 Cache 系统的特质，因此我们可以结合哈希表实现一个简单的缓存系统。这样既能保证能够尽可能多的缓存信息，又可以保证 Java虚拟机不会因为内存泄露而抛出  OutOfMemoryError  。这种缓存机制特别适合于内存对象生命周期长，且生成内存对象的耗时比较长的情况，例如缓存列表封面图片等。对于一些生命周期较长，但是生成内存对象开销不大的情况，使用WeakReference 能够达到更好的内存管理的效果。 </p>
</li>
<li><p>如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建；如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用</p>
</li>
</ul>
<h3 id="Handler-可能引起的内存泄漏"><a href="#Handler-可能引起的内存泄漏" class="headerlink" title="Handler 可能引起的内存泄漏"></a>Handler 可能引起的内存泄漏</h3><hr>
<p>我们经常会写这样的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>当你这样写的时候，你一定会收到编译器的黄色警告。</p>
<blockquote>
<p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p>
</blockquote>
<p><strong>在 Java 中，非静态的内部类和匿名内部类都会 <em>隐式地</em>  持有其外部类的引用</strong>。由于Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也不可能被释放，当一个对象已经不需要再使用了，本来该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</p>
<p>要解决这样的问题，我们在继承 <code>Handler</code> 的时候，要么是放在单独的类文件中，要么直接使用静态内部类，静态的内部类不会持有外部类的引用。当需要在静态内部类中调用外部的 Activity 的时候，我们可以直接采用<strong>弱引用</strong>进行处理，所以我们大概修改后的代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mWeakReference;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span></span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            MainActivity activity = mWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 开始写业务代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> MyHandler mMyHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>其实在我们实际开发中，不止一个地方可能会用到内部类，我们都需要在这样的情况下尽量使用静态内部类加弱引用的方式解决我们可能出现的内存泄漏问题。</p>
]]></content>
  </entry>
  <entry>
    <title>Hashmap</title>
    <url>/2021/11/19/HashMap/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap 是一个<strong>散列表</strong>(hash table)，它存储的内容是<strong>键值对(key-value)映射</strong>。</p>
<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>
<p><img src="https://i.loli.net/2021/11/10/kYDtBx2dwRmeKTS.png" alt="未命名文件 (15).png"></p>
<a id="more"></a>



<blockquote>
<p>HashMap既然继承了AbstractMap为什么还要实现Map</p>
<p>据java集合框架的创始人Josh Bloch描述，这样的写法是一个失误。</p>
</blockquote>
<p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但<strong>遍历顺序却是不确定的</strong>。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</p>
<p>HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e4a19398.png"></p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>在HashMap中有一个 Node[] 类型的table变量，即哈希桶数组</p>
<p>它在第一次使用时初始化，并根据需要调整大小。分配时，长度始终为2的幂。</p>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;<span class="comment">////链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Map.Entry&lt;K, V&gt;具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.<span class="function">NullFromTypeParam <span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.<span class="function">NullFromTypeParam <span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.<span class="function">NullFromTypeParam <span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(<span class="meta">@libcore</span>.util.NullFromTypeParam V value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="meta">@libcore</span>.util.Nullable java.lang.Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//Java8后，接口里可以声明静态方法，并且可以实现。该方法不可以被实现类重写</span></span><br><span class="line"><span class="meta">@libcore</span>.util.NonNull <span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends java.lang.Comparable&lt;? <span class="keyword">super</span> K&gt;, V&gt; java.util.Comparator&lt;java.util.Map.<span class="meta">@libcore</span>.util.NonNull Entry&lt;<span class="meta">@libcore</span>.util.NonNull K, <span class="meta">@libcore</span>.util.Nullable V&gt;&gt; comparingByKey() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stub!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.NonNull <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V extends java.lang.Comparable&lt;? <span class="keyword">super</span> V&gt;&gt; java.util.Comparator&lt;java.util.Map.<span class="meta">@libcore</span>.util.NonNull Entry&lt;<span class="meta">@libcore</span>.util.Nullable K, <span class="meta">@libcore</span>.util.NonNull V&gt;&gt; comparingByValue() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stub!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.NonNull <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; java.util.Comparator&lt;java.util.Map.<span class="meta">@libcore</span>.util.NonNull Entry&lt;<span class="meta">@libcore</span>.util.NullFromTypeParam K, <span class="meta">@libcore</span>.util.Nullable V&gt;&gt; comparingByKey(<span class="meta">@libcore</span>.util.NonNull java.util.Comparator&lt;? <span class="keyword">super</span> <span class="meta">@libcore</span>.util.NullFromTypeParam K&gt; cmp) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stub!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@libcore</span>.util.NonNull <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; java.util.Comparator&lt;java.util.Map.<span class="meta">@libcore</span>.util.NonNull Entry&lt;<span class="meta">@libcore</span>.util.Nullable K, <span class="meta">@libcore</span>.util.NullFromTypeParam V&gt;&gt; comparingByValue(<span class="meta">@libcore</span>.util.NonNull java.util.Comparator&lt;? <span class="keyword">super</span> <span class="meta">@libcore</span>.util.NullFromTypeParam V&gt; cmp) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Stub!&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash碰撞及解决方法"><a href="#Hash碰撞及解决方法" class="headerlink" title="Hash碰撞及解决方法"></a>Hash碰撞及解决方法</h3><h4 id="Hash碰撞"><a href="#Hash碰撞" class="headerlink" title="Hash碰撞"></a>Hash碰撞</h4><p>当向HashMap中存数据时，需要提供key和value。HashMap将会调用key的hashCode()方法经过hash()计算得到其hash值，最后根据hash值确定Node放在数组的哪个位置。</p>
<p><strong>Hash碰撞即拥有不同hash值的对象经过计算后对应同一个数组位置。</strong></p>
<p>当Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法，Node也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的Hash算法减少Hash碰撞</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。</p>
<p>在Java中HashMap使用了链地址法。</p>
<p>虽然链地址法是一种很好的处理哈希冲突的方法，但是在一些极端情况下链地址法也会出现问题。</p>
<p>比如在某一个哈希桶中的链表过长，这样在进行查询操作时依然很耗时。所以JDK1.8对HashMap底层的实现进行了优化，引入**<em>红黑树**</em>的数据结构。</p>
<h3 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash()方法"></a>hash()方法</h3><p>实现具体如下：</p>
<p>通过(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)将低16位与高16位做异或运算得到hash值，至于为什么要这样做，后面再进行解释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>hashCode()方法继承自Object类，当使用自定义对象作为HashMap的key,需要重写hashCode()和equals()方法</li>
</ul>
</blockquote>
<h3 id="table中下标值计算"><a href="#table中下标值计算" class="headerlink" title="table中下标值计算"></a>table中下标值计算</h3><p>下标值的实际是hash值对table的长度进行取模运算的结果，即不同的hash值也有可能在相同的hash桶中</p>
<p>在table中的index =  hash&amp;(length - 1) </p>
<p><strong>hash%length==hash&amp;(length-1)</strong></p>
<p>前提是length是2的n次方，该等式的证明如下：</p>
<p><img src="https://i.loli.net/2021/10/24/Z6J8QzurtnA2aNL.jpg" alt="IMG_0591(20211024-001634).PNG"></p>
<p>用hash&amp;(length-1)计算可以优化计算速度，因为位运算比取余运算效率高很多。且这样计算可以减少碰撞。</p>
<p>为什么这样能减少碰撞呢？</p>
<p>2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1； 例如长度为9时候，3&amp;(9-1)=0  2&amp;(9-1)=0 ，都在0上碰撞了,即无论什么数字与0进行&amp;运算都为0； 例如长度为8时候，3&amp;(8-1)=3  2&amp;(8-1)=2 ，都是与1进行&amp;运算，其值根据数的具体值得到</p>
<blockquote>
<p>其实就是按位“与”的时候，每一位都能  &amp;1  ，也就是和1111……1111111进行与运算  </p>
</blockquote>
<p>上面我们提到，hash值的计算方法：h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，原因如下：</p>
<p>​    我们已经知道在计算下标时按位与进行计算可以更快。</p>
<p>​    数组长度一般而言是小于2的16次方65535的,也就说数组长度的高16位一般全是0。</p>
<p>​    那么hash值的高位相当于全部没有作用,因为x&amp;0=0,无论x是1还是0,这样hash冲突的几率会很大,为什么呢?</p>
<p>​    因为如果有很多hash值,它们的低16位相同,但高16都不相同,那么它们得到的索引值却是一样的,会产生冲突</p>
<p>​    低16位和高16位做了异或运算,这样低16位的值同时拥有了高16位的特征,即使hash值的低16位一样，在做&amp;运算时结果也就不一样,从而减少了冲突的可能</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//table为null或长度为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化或扩容</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//tab[i]是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//根据传入的值创建新的节点并放在tab[i]</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果key已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//赋值给e</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果是树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//用红黑树的方法插入该节点</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//没有与待插入Node的key相同的key</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//创建Node并插入链表</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//TREEIFY_THRESHOLD值为8，如果链表长度大于8，则转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//若原先的map中有该key</span></span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//继续遍历</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若不为null，则待插入Node的key原先存在</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//onlyIfAbsent为true时不改变原先key对应的value值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的modCount与集合的fail-fast 机制有关  <a href="https://juejin.cn/post/6879291161274482695#heading-0">fail-fast博客</a></p>
</blockquote>
<p>put的流程图如下</p>
<p><img src="https://i.loli.net/2021/11/15/Z1r5Dk9u3SXR8Kc.png" alt="未命名文件 (16).png"></p>
<h3 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始容量为16，其值必须是2的整数次方</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map中所能容纳的最大键值对个数，当元素数量超过这个值时，将进行扩容；</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map中实际存在的键值对的个数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>首先要知道一个重要公式：</p>
<p>*<em>threshold=capacity * load factor*</em></p>
<p>即map中能容纳的最大键值对个数等于容量（hash桶的长度）*负载因子</p>
<p>负载因子 <strong>α= 哈希表中元素数/哈希桶数组长度</strong></p>
<p>很显然，<strong>α</strong>的值越小哈希冲突的概率越小，查找时的效率也就越高。而减小<strong>α</strong>的值就意味着降低了哈希表的使用率。显然这是一个矛盾的关系，不可能有完美解。为了兼顾彼此，装填因子的最大值一般选在0.65~0.9之间。比如HashMap中就将装填因子定为0.75。一旦HashMap的装填因子大于0.75的时候，为了减少哈希冲突，就需要对哈希表进行<strong>扩容</strong>操作。比如我们可以将哈希表的长度扩大到原来的2倍。</p>
<h3 id="table扩容"><a href="#table扩容" class="headerlink" title="table扩容"></a>table扩容</h3><p>这里我们应该知道，扩容并不是在原数组基础上扩大容量，而是需要申请一个长度为原来2倍的新数组。因此，扩容之后就需要将原来的数据从旧数组中重新散列存放到扩容后的新数组。这个过程我们称之为<strong>Rehash</strong>。</p>
<p>接下来看关于扩容的函数resize()的源码：</p>
<p>resize中主要进行初始化或扩容的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//默认初始容量为16，其值必须是2的整数次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line">	<span class="comment">//最大容量，2的30次方</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示存储数据的数组已经被初始化过</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前容量是否超过最大容量</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             <span class="comment">// 若超过最大容量，表示无法再进行扩容。更新threshold为int的最大值，并返回旧数组</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当容量变为原先的两倍小于最大容量</span></span><br><span class="line">            <span class="comment">//且原先的容量超过默认值（16）时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 变成原来的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不满足上面的oldCap &gt; 0，即原先数组未进行过初始化</span></span><br><span class="line"><span class="comment">       	若当前阈值不为0，就将数组的新容量记录为当前的阈值；</span></span><br><span class="line"><span class="comment">    	为什么这里的oldThr在未初始化数组的时候就有值呢？</span></span><br><span class="line"><span class="comment">    	这是因为HashMap有两个带参构造器，可以指定初始容量，</span></span><br><span class="line"><span class="comment">     	若你调用了这两个可以指定初始容量的构造器，</span></span><br><span class="line"><span class="comment">     	这两个构造器就会将阈值记录为第一个大于等于你指定容量，且满足2^n的数 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 若上面的条件都不满足，表示你是调用默认构造器创建的HashMap，且还没有初始化table数组</span></span><br><span class="line">        <span class="keyword">else</span> &#123;            <span class="comment">//用默认值去初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 经过上面的步骤后，newCap一定有值，但是newThr有可能是0</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="comment">//接下来的代码后面会讲</span></span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>计算容量的流程图如下：</p>
<blockquote>
<p>int oldCap = (oldTab == null) ? 0 : oldTab.length;<br>int oldThr = threshold;<br>int newCap, newThr = 0;</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/19/dPIbv37q2DE5Vhf.png" alt="未命名文件 (17).png"></p>
<p><strong>确定好容量以后考虑如何将原来的Node放到新的table中</strong></p>
<p>先通过JDK1.7的源码理解一下扩容的基本原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看transfer()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//重新计算每个元素在数组中的位置</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//1</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>1处待插入元素e的next为它该在的数组位置的引用，然后将待插入的e放在该位置上。即待插入的元素将采用**<em>头插法**</em>放在相应的数组位置。</p>
<p><strong>扩容流程图示如下</strong>：</p>
<blockquote>
<p>注：假设Node方框中的值为key的hash值</p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/29/qh7aXBndH3yZbSg.png" alt="未命名文件 (9).png"></p>
<p>根据之前说过的计算Node在table数组中的哪个位置的方法（index =  hash&amp;(length - 1) ）可知Node这样放置的原因：</p>
<p><img src="https://i.loli.net/2021/10/29/58Y4zTS3UmuRwCx.jpg" alt="IMG_0607(20211029-153420).PNG"></p>
<p>观察上图可知，扩容2倍后，n-1会把原先最高位1前的0变成1，这样hash值与n-1进行位运算时，可以多检测该位的值。</p>
<p>若hash值在该位为0，则在扩容后的数组位置下标和原先一样。</p>
<p>若hash值在该位为1，则在扩容后的数组位置会加上多出来的那一位的值，在本例中就是100，也就是4，所以hash为6的Node在数组中的位置为2+4 =6</p>
<p><strong>所以我们可以发现，扩容后，Node在数组中的位置下标要么和原来一样，要么加上多出那一位对应的值，实际也就是原先数组的大小。</strong></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算index，只需要看看它的hash值新增的那个bit是1还是0就好了。这就是JDK1.8做出的优化。</p>
<p>接下来看JDK1.8的扩容策略，依旧是resize()中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="comment">//当原数组的位置j有元素时才继续下面的操作</span></span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//先释放原位置的引用</span></span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">// 若原先table数组的j位置只有一个节点，则直接将这个节点计算出下标值后放入新数组</span></span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                  </span><br><span class="line">   <span class="comment">// 若第一个节点是一个树节点，表示原数组这个位置的链表已经被转为了红黑树，直接调用红黑树的方法将节点加入到新数组中</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                  </span><br><span class="line"><span class="comment">// 上面两种情况都不满足，表示这个位置是一条不止一个节点的链表</span></span><br><span class="line">                  <span class="keyword">else</span> &#123; </span><br><span class="line">       <span class="comment">//根据之前说的，扩容后Node的在数组的位置只有两种情况，也就是最多有两个位置的链表存储原位置的所有Node</span></span><br><span class="line">      <span class="comment">//所以我们可以先把这两个链表构建出来，最后再插入数组的相应位置</span></span><br><span class="line">      Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">   Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">      <span class="comment">//遍历数组j位置链表上的节点</span></span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">         next = e.next;</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// e.hash &amp; oldCap（10...0）这一步就是前面说的判断多出的这一位是否为1</span></span><br><span class="line">  	<span class="comment">// 若与原容量做与运算，结果为0，表示将这个节点放入到新数组中，下标不变</span></span><br><span class="line">          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//接下来是构建存储下标不变的Node的链表的操作</span></span><br><span class="line">         <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             loTail.next = e;</span><br><span class="line">		loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 若与原容量做与运算，结果为1，表示将这个节点放入到新数组中，下标将改变</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//接下来是构建存储下标改变的Node的链表的操作</span></span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">             hiHead = e;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         hiTail.next = e;</span><br><span class="line">           hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 所有节点遍历完后，判断我们构建的下标不变的链表是否有节点</span></span><br><span class="line">               <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">   		 <span class="comment">// 将这条链表的最后一个节点的next指向null</span></span><br><span class="line">              loTail.next = <span class="keyword">null</span>;</span><br><span class="line">       	<span class="comment">// 将其放入新数组的相同位置</span></span><br><span class="line">               newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">  <span class="comment">// 所有节点遍历完后，判断我们构建的下标改变的链表是否有节点</span></span><br><span class="line">              <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">              hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 这条链表放入的位置要在原先的下标值基础上加上oldCap</span></span><br><span class="line">              newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>ViewPager及懒加载与预加载分析</title>
    <url>/2021/10/15/ViewPager/</url>
    <content><![CDATA[<h2 id="ViewPager的使用"><a href="#ViewPager的使用" class="headerlink" title="ViewPager的使用"></a>ViewPager的使用</h2><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><hr>
<p>网上一些教程上会运用以下方式在PagerAdapter中获取Fragment实例，即在构造PagerAdapter时传入相应的Fragment列表，也就是在构造PagerAdapter前已经将所有Fragment进行了初始化。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Fragment&gt; fragmentList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestFragmentPagerAdapter</span><span class="params">(FragmentManager fm, List&lt;Fragment&gt; fragmentList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fm);</span><br><span class="line">        <span class="keyword">this</span>.fragmentList = fragmentList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fragmentList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fragmentList.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="官方用法"><a href="#官方用法" class="headerlink" title="官方用法"></a>官方用法</h3><hr>
<p>但查看官方示例代码可发现，官方更加倾向于以下创建Fragment实例的方式。即在getItem()中开始创建实例，而非将所有实例创建好然后传入PagerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyAdapter</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> NUM_ITEMS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ArrayListFragment.newInstance(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *ListFragment is the same as a ListActivity - it&#x27;s just a Fragment,</span></span><br><span class="line"><span class="comment">     *that extends List methods. You can just add Fragment, that contains ListView and implement</span></span><br><span class="line"><span class="comment">     *all required for list methods, like in Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create a new instance of CountingFragment, providing &quot;num&quot;</span></span><br><span class="line"><span class="comment">         * as an argument.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> ArrayListFragment <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            ArrayListFragment f = <span class="keyword">new</span> ArrayListFragment();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Supply num input as an argument.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            为什么不通过构造函数直接传参数？详见</span></span><br><span class="line"><span class="comment">https://blog.csdn.net/tu_bingbing/article/details/24143249</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">            args.putInt(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">            f.setArguments(args);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * When creating, retrieve this instance&#x27;s number from its arguments.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            mNum = getArguments() != <span class="keyword">null</span> ? getArguments().getInt(<span class="string">&quot;num&quot;</span>) : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The Fragment&#x27;s UI is just a simple text view showing its</span></span><br><span class="line"><span class="comment">         * instance number.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            View v = inflater.inflate(R.layout.fragment_pager_list, container, <span class="keyword">false</span>);</span><br><span class="line">            View tv = v.findViewById(R.id.text);</span><br><span class="line">            ((TextView) tv).setText(<span class="string">&quot;Fragment #&quot;</span> + mNum);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">            setListAdapter(<span class="keyword">new</span> ArrayAdapter&lt;String&gt;(getActivity(),</span><br><span class="line">                    android.R.layout.simple_list_item_1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">            Log.i(<span class="string">&quot;FragmentList&quot;</span>, <span class="string">&quot;Item clicked: &quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>getItem()方法中创建实例也可以使用工厂模式</p>
</blockquote>
<p>为什么不推荐提前初始化所有Fragment？</p>
<p>虽然大部分Fragment的初始化并未有太大的消耗，但不排除一些特殊情况，比如在Fragment中进行例如new一个较大的数组这种操作。</p>
<h2 id="ViewPager及PagerAdapter实现类分析"><a href="#ViewPager及PagerAdapter实现类分析" class="headerlink" title="ViewPager及PagerAdapter实现类分析"></a>ViewPager及PagerAdapter实现类分析</h2><h3 id="ViewPager源码分析"><a href="#ViewPager源码分析" class="headerlink" title="ViewPager源码分析"></a>ViewPager源码分析</h3><hr>
<p>从ViewPager的setAdapter()方法看起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(<span class="meta">@Nullable</span> PagerAdapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果存在旧的Adapter,销毁旧的Adapter的数据</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAdapter.setViewPagerObserver(<span class="keyword">null</span>);</span><br><span class="line">            mAdapter.startUpdate(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//销毁旧Item的数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mItems.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ItemInfo ii = mItems.get(i);</span><br><span class="line">                mAdapter.destroyItem(<span class="keyword">this</span>, ii.position, ii.object);</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapter.finishUpdate(<span class="keyword">this</span>);</span><br><span class="line">            mItems.clear();</span><br><span class="line">            removeNonDecorViews();</span><br><span class="line">            mCurItem = <span class="number">0</span>;</span><br><span class="line">            scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PagerAdapter oldAdapter = mAdapter;</span><br><span class="line">        mAdapter = adapter;</span><br><span class="line">        mExpectedAdapterCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mObserver == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mObserver = <span class="keyword">new</span> PagerObserver();</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapter.setViewPagerObserver(mObserver);</span><br><span class="line">            mPopulatePending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasFirstLayout = mFirstLayout;</span><br><span class="line">            mFirstLayout = <span class="keyword">true</span>;</span><br><span class="line">            mExpectedAdapterCount = mAdapter.getCount();</span><br><span class="line">            <span class="keyword">if</span> (mRestoredCurItem &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);</span><br><span class="line">                setCurrentItemInternal(mRestoredCurItem, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                mRestoredCurItem = -<span class="number">1</span>;</span><br><span class="line">                mRestoredAdapterState = <span class="keyword">null</span>;</span><br><span class="line">                mRestoredClassLoader = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasFirstLayout) &#123;</span><br><span class="line">                populate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//onMeasure()中也会调用populate()方法</span></span><br><span class="line">                requestLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch the change to any listeners</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterChangeListeners != <span class="keyword">null</span> &amp;&amp; !mAdapterChangeListeners.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = mAdapterChangeListeners.size(); i &lt; count; i++) &#123;</span><br><span class="line">                mAdapterChangeListeners.get(i).onAdapterChanged(<span class="keyword">this</span>, oldAdapter, adapter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下最终会调用populate()方法。</p>
<p>populate()方法主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">populate</span><span class="params">(<span class="keyword">int</span> newCurrentItem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//adapter页面将更改时调用</span></span><br><span class="line">    mAdapter.startUpdate(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mAdapter.getCount();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Locate the currently focused item or add it if needed.</span></span><br><span class="line">    <span class="keyword">int</span> curIndex = -<span class="number">1</span>;</span><br><span class="line">    ItemInfo curItem = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (curIndex = <span class="number">0</span>; curIndex &lt; mItems.size(); curIndex++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ItemInfo ii = mItems.get(curIndex);</span><br><span class="line">            <span class="keyword">if</span> (ii.position &gt;= mCurItem) &#123;</span><br><span class="line">                <span class="comment">//查到时</span></span><br><span class="line">                <span class="keyword">if</span> (ii.position == mCurItem) curItem = ii;</span><br><span class="line">               <span class="comment">//查找到或者往后不会再找到</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//找不到当前需要的item,则add    </span></span><br><span class="line">    <span class="keyword">if</span> (curItem == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curItem = addNewItem(mCurItem, curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...两个循环对左右两边的Fragment进行缓存及清除(代码略)</span></span><br><span class="line">        </span><br><span class="line">    mAdapter.setPrimaryItem(<span class="keyword">this</span>, mCurItem, curItem.object);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemInfo</span> </span>&#123;</span><br><span class="line">        Object object;</span><br><span class="line">        <span class="keyword">int</span> position;</span><br><span class="line">        <span class="keyword">boolean</span> scrolling;</span><br><span class="line">        <span class="keyword">float</span> widthFactor;</span><br><span class="line">        <span class="keyword">float</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//存放缓存的Fragment</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; mItems = <span class="keyword">new</span> ArrayList&lt;ItemInfo&gt;();</span><br><span class="line">    <span class="keyword">int</span> mCurItem;   <span class="comment">// Index of currently displayed page.</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看addNewItem对应的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ItemInfo <span class="title">addNewItem</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       ItemInfo ii = <span class="keyword">new</span> ItemInfo();</span><br><span class="line">       ii.position = position;</span><br><span class="line">       ii.object = mAdapter.instantiateItem(<span class="keyword">this</span>, position);</span><br><span class="line">       ii.widthFactor = mAdapter.getPageWidth(position);</span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= mItems.size()) &#123;</span><br><span class="line">           mItems.add(ii);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mItems.add(index, ii);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ii;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里调用了mAdapter.instantiateItem()方法，它的实现类是setAdapter()设置的PagerAdapter。接下来看一下PagerAdapter的两个实现类。</p>
<h3 id="直观感受两种PagerAdapter实现类的区别"><a href="#直观感受两种PagerAdapter实现类的区别" class="headerlink" title="直观感受两种PagerAdapter实现类的区别"></a>直观感受两种PagerAdapter实现类的区别</h3><hr>
<h4 id="FragmentPagerAdapter"><a href="#FragmentPagerAdapter" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h4><hr>
<ul>
<li><p>适用于在固定的少量同级屏幕之间进行导航。</p>
</li>
<li><p>默认预加载当前Fragment及左右两个Fragment，若左边或右边无Fragment则不加载。</p>
<p><img src="https://i.loli.net/2021/10/15/BRjuCawQDktniX7.jpg" alt="IMG_0559.PNG"></p>
</li>
<li><blockquote>
<p>当前Fragment即为ViewPager中的CurrentItem,默认设置为0</p>
<p>默认加载的左右两个Fragment，是根据mOffscreenPageLimit计算出的，mOffscreenPageLimit默认为1，所以默认预加载左右各一个Fragment</p>
<p>本例均使用默认值</p>
</blockquote>
<p>在加载最左边，即第一个Fragment时，生命周期如下。</p>
<p>可见当前Fragment及其右边的Fragment都会执行到onResume()方法</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/10/11/4UV6ClNTWhGDnYr.png" alt="屏幕截图(229).png"></p>
<ul>
<li><p>当继续切换到第三个Fragment时，默认会缓存第二个Fragment和第四个Fragment，而刚开始已经加载过的Fragment生命周期会执行到onDestroyView(),并未执行onDestroy()方法，即Fragment的实例数据还存在，只是View被销毁了</p>
<p><img src="https://i.loli.net/2021/10/15/WBaQDzhiG9oLNpm.jpg" alt="IMG_0560.PNG"></p>
</li>
</ul>
<h4 id="FragmentStatePagerAdapter"><a href="#FragmentStatePagerAdapter" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h4><hr>
<ul>
<li><p>适用于对未知数量的页面进行分页。<code>FragmentStatePagerAdapter</code> 会在用户导航至其他位置时销毁 Fragment，从而优化内存使用情况</p>
</li>
<li><p>默认刚开始加载的Fragment的生命周期同上。</p>
</li>
<li><p>当切换到第三个Fragment时，最左边的Fragment会执行到onDetach()方法，即被销毁了。图略。</p>
</li>
</ul>
<h3 id="两种PagerAdapter实现类源码分析"><a href="#两种PagerAdapter实现类源码分析" class="headerlink" title="两种PagerAdapter实现类源码分析"></a>两种PagerAdapter实现类源码分析</h3><hr>
<h4 id="instantiateItem-方法"><a href="#instantiateItem-方法" class="headerlink" title="instantiateItem()方法"></a>instantiateItem()方法</h4><hr>
<h5 id="FragmentPagerAdapter-1"><a href="#FragmentPagerAdapter-1" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//根据position得到itemId,该方法默认返回position</span></span><br><span class="line">        <span class="keyword">long</span> itemId = <span class="keyword">this</span>.getItemId(position);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//生成tag,默认返回 &quot;android:switcher:&quot; + viewId + &quot;:&quot; + id</span></span><br><span class="line">        String name = makeFragmentName(container.getId(), itemId);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//根据tag到FragmentManager中寻找Fragment的实例</span></span><br><span class="line">        Fragment fragment = <span class="keyword">this</span>.mFragmentManager.findFragmentByTag(name);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//找到就调用attach方法</span></span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.attach(fragment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则调用getItem()获取Fragment实例，该方法是创建该FragmentPagerAdapter时会重			//写的</span></span><br><span class="line">            fragment = <span class="keyword">this</span>.getItem(position);</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断当前Fragment是否为获得焦点的当前Fragment</span></span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.STARTED);<span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">makeFragmentName</span><span class="params">(<span class="keyword">int</span> viewId, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;android:switcher:&quot;</span> + viewId + <span class="string">&quot;:&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果 behavior 的值为 <code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>，那么当 Fragment 对用户的可见状态发生改变时，<code>setUserVisibleHint</code> 方法会被调用。</li>
<li>如果 behavior 的值为 <code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code> ，那么当前选中的 Fragment 在 <code>Lifecycle.State#RESUMED</code> 状态 ，其他不可见的 Fragment 会被限制在 <code>Lifecycle.State#STARTED</code> 状态。</li>
</ul>
<p>mBehavior的值默认为BEHAVIOR_SET_USER_VISIBLE_HINT，如果想要设置，可以在自定义的FragmentPagerAdapter的构造函数中调用super(fm,FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);</p>
</blockquote>
<p>注释1处，上述例子如果设置了mBehavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT，则该预加载的Fragment生命周期只会执行到onStart()，原因是调用了setMaxLifecycle()。该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 超过了设置的最大状态，那么会强制将 Fragment 降级到相应的状态。<a href="https://juejin.cn/post/6844904033774206984">详细可以看这篇博客</a></p>
<h5 id="FragmentStatePagerAdapter-1"><a href="#FragmentStatePagerAdapter-1" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SavedState是Fragment类里的，用于保存Bundle的信息</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;SavedState&gt; mSavedState;</span><br><span class="line"><span class="comment">//并非保存所有Fragment，而是保存根据mOffscreenPageLimit算出来的个数的Fragment</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Fragment&gt; mFragments;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Fragment fragment;</span><br><span class="line">    	<span class="comment">//先判断是否缓存了该Fragment，若有则直接复用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mFragments.size() &gt; position) &#123;</span><br><span class="line">            fragment = (Fragment)<span class="keyword">this</span>.mFragments.get(position);</span><br><span class="line">            <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> fragment;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//getItem是自行重写的方法</span></span><br><span class="line">        fragment = <span class="keyword">this</span>.getItem(position);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//查询是否保存有对应的Bundle信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mSavedState.size() &gt; position) &#123;</span><br><span class="line">            SavedState fss = (SavedState)<span class="keyword">this</span>.mSavedState.get(position);</span><br><span class="line">            <span class="keyword">if</span> (fss != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fragment.setInitialSavedState(fss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.mFragments.size() &lt;= position) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mFragments.add((Object)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        fragment.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == BEHAVIOR_SET_USER_VISIBLE_HINT) &#123;</span><br><span class="line">            fragment.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//保存Fragment信息</span></span><br><span class="line">        <span class="keyword">this</span>.mFragments.set(position, fragment);</span><br><span class="line">        <span class="keyword">this</span>.mCurTransaction.add(container.getId(), fragment);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior ==  BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="destroyItem-方法"><a href="#destroyItem-方法" class="headerlink" title="destroyItem()方法"></a>destroyItem()方法</h4><h5 id="FragmentPagerAdapter-2"><a href="#FragmentPagerAdapter-2" class="headerlink" title="FragmentPagerAdapter"></a>FragmentPagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">       Fragment fragment = (Fragment)object;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	detach是从UI中将fragment的元素去掉，但是依然保留状态，</span></span><br><span class="line"><span class="comment">    	当调用attach的时候重新将之前的fragment连同状态一起恢复。 </span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">       <span class="keyword">this</span>.mCurTransaction.detach(fragment);</span><br><span class="line">       <span class="keyword">if</span> (fragment == <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurrentPrimaryItem = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="FragmentStatePagerAdapter-2"><a href="#FragmentStatePagerAdapter-2" class="headerlink" title="FragmentStatePagerAdapter"></a>FragmentStatePagerAdapter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">       Fragment fragment = (Fragment)object;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">this</span>.mSavedState.size() &lt;= position) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mSavedState.add((Object)<span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.mSavedState.set(position, fragment.isAdded() ? <span class="keyword">this</span>.mFragmentManager.saveFragmentInstanceState(fragment) : <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">this</span>.mFragments.set(position, (Object)<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//remove是将fragment从UI中去掉，状态无法恢复了</span></span><br><span class="line">       <span class="keyword">this</span>.mCurTransaction.remove(fragment);</span><br><span class="line">       <span class="keyword">if</span> (fragment == <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">           <span class="keyword">this</span>.mCurrentPrimaryItem = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过两个destroyItem()的实现可以发现，对fragment的不同销毁方法决定了fragment的生命周期。这也是为什么之前讲的，两种PagerAdapter对于超出预加载范围的Fragment的销毁，FragmentPagerAdapter对应的Fragment会执行到onDestroyView()方法，而FragmentStatePagerAdapter对应的Fragment会执行到onDetach()方法。</p>
<h4 id="setPrimaryItem-方法"><a href="#setPrimaryItem-方法" class="headerlink" title="setPrimaryItem()方法"></a>setPrimaryItem()方法</h4><hr>
<p>以上两个PagerAdapter的子类对其的实现是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup container, <span class="keyword">int</span> position, <span class="meta">@NonNull</span> Object object)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//fragment是将要显示的Fragment，mCurrentPrimaryItem是目前正在显示的Fragment</span></span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">this</span>.mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">                    &#125;</span><br><span class="line">		<span class="comment">//将当前显示的Fragment的MaxLifecycle设置为STARTED。</span></span><br><span class="line">        <span class="comment">//即其生命周期从onResume回退到onStart</span></span><br><span class="line">                    <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(<span class="keyword">this</span>.mCurrentPrimaryItem, State.STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mBehavior == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mCurTransaction = <span class="keyword">this</span>.mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//将即将显示的Fragment的MaxLifecycle设置为RESUMED</span></span><br><span class="line">            <span class="comment">//所以该fragment生命周期从onStart变成onResume</span></span><br><span class="line">                <span class="keyword">this</span>.mCurTransaction.setMaxLifecycle(fragment, State.RESUMED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="预加载和懒加载"><a href="#预加载和懒加载" class="headerlink" title="预加载和懒加载"></a>预加载和懒加载</h2><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><hr>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><hr>
<p>  ViewPager的预加载机制会默认一次加载当前页面前后两个页面，预加载界面的个数可以自行设置。但至少会预加载前后各一个界面。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><hr>
<p>预加载在一定程度上可以保证切换界面时可以很快地见到加载完数据的完整界面，但其代价是，在不切换到别的界面时，别的界面会进行耗时的获取数据操作，这可能导致当前界面获取数据时发生卡顿。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><hr>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><hr>
<p>懒加载也可以叫做延迟加载，即当界面可见时再进行数据的加载。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><hr>
<p>懒加载可以通过对数据的延迟加载，解决因为预加载导致的性能降低的问题。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><hr>
<h5 id="传统处理方式"><a href="#传统处理方式" class="headerlink" title="传统处理方式"></a>传统处理方式</h5><hr>
<blockquote>
<ul>
<li><p>使用 ViewPager切换 Fragment 页面时（已经初始化完毕），只有 setUserVisibleHint(boolean isVisibleToUser) 会被回调。</p>
</li>
<li><p>setUserVisibleHint(boolean isVisibleToUser) 方法总是会优先于 Fragment 生命周期函数的调用。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当前Fragment是否可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isVisibleToUser = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//Fragment的View是否被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isViewCreated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否第一次加载数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstLoad = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="keyword">this</span>.isVisibleToUser = isVisibleToUser;</span><br><span class="line">        <span class="comment">//当setUserVisibleHint被回调时，会调用懒加载方法，这里其实可以进一步判断处理</span></span><br><span class="line">        <span class="comment">//如当可见时进行加载操作，不可见时停止加载</span></span><br><span class="line">        onLazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> View view, <span class="meta">@Nullable</span> <span class="meta">@org</span>.jetbrains.annotations.Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        <span class="comment">//View创建成功</span></span><br><span class="line">        isViewCreated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这个函数被真正调用主要在于第一个Fragment加载的时候</span></span><br><span class="line">        <span class="comment">//因为最开始setUserVisibleHint执行时，view还未创建。</span></span><br><span class="line">        onLazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; isFirstLoad)&#123;</span><br><span class="line">            isFirstLoad = <span class="keyword">false</span>;</span><br><span class="line">            lazyLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//子类实现具体的加载逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Androidx-下的懒加载"><a href="#Androidx-下的懒加载" class="headerlink" title="Androidx 下的懒加载"></a>Androidx 下的懒加载</h5><hr>
<p>Google 在 Androidx 在 FragmentTransaction 中增加了 setMaxLifecycle 方法来控制 Fragment 所能调用的最大的生命周期函数。</p>
<p>该方法可以设置活跃状态下 Fragment 最大的状态，如果该 Fragment 生命周期超过了设置的最大状态，那么会强制将 Fragment 降级到设置的状态。</p>
<p>结合之前讲的，可以在PagerAdapter子类的构造函数中调用super(fm,BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);来实现当前Fragment生命周期执行到onResume,预加载的Fragment生命周期执行到onStart,这样，就不会存在提前加载数据的情况了。</p>
<p>因此懒加载的方式变得更加简洁，不再需要多个标志位判断这样不优雅的代码实现懒加载的功能了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLifecycleFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isFirstLoad = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        <span class="keyword">if</span> (isFirstLoad) &#123;</span><br><span class="line">        	isFirstLoad = <span class="literal">false</span></span><br><span class="line">            loadData()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>预加载和懒加载都有一定的应用场景，在数据加载量少的时候不用懒加载也不会有很大的影响。</p>
<p>而懒加载的具体代码也可以根据具体的业务逻辑来确定，比如加载过数据的Fragment被destroyItem()方法处理后，再显示该Fragment的逻辑，因为从前面的分析可以知道具体的destroyItem()逻辑在不同PagerAdapter的实现类中是不一样的。</p>
<p>所以上面的代码只是最基础的代码逻辑参考，具体的逻辑可以在此基础上修改。</p>
<h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>ViewPager2 是 ViewPager 库的改进版本，可提供增强型功能并解决使用 ViewPager时遇到的一些常见问题。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><hr>
<ul>
<li><p>垂直方向支持</p>
</li>
<li><p>DiffUtil</p>
<blockquote>
<p>ViewPager2在 RecyclerView的基础上构建而成，这意味着它可以访问 DiffUtil 实用程序类。这一点带来了多项优势，但最突出的一项是，这意味着 ViewPager2 对象本身会利用 RecyclerView 类中的数据集更改动画</p>
</blockquote>
</li>
<li><p>可修改的 Fragment 集合</p>
<blockquote>
<p>ViewPager2 支持对可修改的 Fragment 集合进行分页浏览，在底层集合发生更改时调用 notifyDatasetChanged() 来更新界面。</p>
<p>这意味着，您的应用可以在运行时动态修改 Fragment 集合，而 ViewPager2 会正确显示修改后的集合。</p>
</blockquote>
</li>
</ul>
<h3 id="ViewPager迁移到-ViewPager2"><a href="#ViewPager迁移到-ViewPager2" class="headerlink" title="ViewPager迁移到 ViewPager2"></a>ViewPager迁移到 ViewPager2</h3><hr>
<h4 id="主要代码变化"><a href="#主要代码变化" class="headerlink" title="主要代码变化"></a>主要代码变化</h4><hr>
<ol>
<li>将父类更改为 RecyclerView.Adapter 用于分页浏览视图，更改为 FragmentStateAdapter 用于分页浏览 Fragment。</li>
<li>更改基于 Fragment 的适配器类中的构造函数参数。</li>
<li>替换 <code>getItemCount()</code>，而不是 <code>getCount()</code>。</li>
<li>在基于 Fragment 的适配器类中，替换 createFragment()，而不是 getItem()。</li>
</ol>
<h4 id="若使用了TabLayout"><a href="#若使用了TabLayout" class="headerlink" title="若使用了TabLayout"></a>若使用了TabLayout</h4><hr>
<p> TabLayout 与 ViewPager 集成使用的是它自己的 setupWithViewPager() 方法，但是如果要与 ViewPager2 集成，却需要使用 TabLayoutMediator 实例。</p>
<p>TabLayoutMediator 对象还可处理为 TabLayout 对象生成页面标题的任务，这意味着相关适配器类不需要替换 getPageTitle()</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tabLayout = view.findViewById(R.id.tab_layout)</span><br><span class="line">TabLayoutMediator(tabLayout, viewPager) &#123; tab, position -&gt;</span><br><span class="line">    tab.text = <span class="string">&quot;OBJECT <span class="subst">$&#123;(position + <span class="number">1</span>)&#125;</span>&quot;</span></span><br><span class="line">&#125;.attach()</span><br></pre></td></tr></table></figure>



<h3 id="OffscreenPageLimit"><a href="#OffscreenPageLimit" class="headerlink" title="OffscreenPageLimit"></a>OffscreenPageLimit</h3><hr>
<p>查看相应的setOffscreenPageLimit()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OFFSCREEN_PAGE_LIMIT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@OffscreenPageLimit</span> <span class="keyword">int</span> mOffscreenPageLimit = OFFSCREEN_PAGE_LIMIT_DEFAULT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffscreenPageLimit</span><span class="params">(<span class="meta">@OffscreenPageLimit</span> <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (limit &lt; <span class="number">1</span> &amp;&amp; limit != OFFSCREEN_PAGE_LIMIT_DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;Offscreen page limit must be OFFSCREEN_PAGE_LIMIT_DEFAULT or a number &gt; 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mOffscreenPageLimit = limit;</span><br><span class="line">        <span class="comment">// Trigger layout so prefetch happens through getExtraLayoutSize()</span></span><br><span class="line">        mRecyclerView.requestLayout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewPager2的limit必须大于0或者为-1。limit的值不应该过大，尤其是在界面复杂的情况下。</p>
<p>limit的值默认设置为OFFSCREEN_PAGE_LIMIT_DEFAULT（即-1）。OFFSCREEN_PAGE_LIMIT_DEFAULT表示使用RecyclerView的默认缓存机制(刚开始只加载当前界面)，而不是显式地将页面预取并保留到当前页面的任一侧。</p>
<p>当加载第一个界面时，其对应加载的Fragment的生命周期如下<img src="https://i.loli.net/2021/10/13/LA7KSwpDPCihGMb.png" alt="屏幕截图(231).png"></p>
<p>当切换到下一个Fragment时，生命周期如下:</p>
<p>第一个Fragment的生命周期会到onPause()</p>
<p><img src="https://i.loli.net/2021/10/15/ezgFpdrPhQXcBis.png" alt="屏幕截图(233).png"></p>
<p>继续切换到下一个Fragment，生命周期如下。</p>
<p>可以发现，此时并不会对第一个Fragment进行销毁。</p>
<p><img src="https://i.loli.net/2021/10/15/2cfkJgrST4ma1uB.png" alt="屏幕截图(235).png"></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/1d95e729c571">关于RecyclerView的默认缓存机制和预取机制及其对Fragment的销毁情况可以看这个博客</a></p>
</blockquote>
<h3 id="懒加载-1"><a href="#懒加载-1" class="headerlink" title="懒加载"></a>懒加载</h3><hr>
<p>当通过setOffscreenPageLimit()设置了limit不为-1时，预加载的Fragment生命周期只执行到onStart()。显然是在FragmentStateAdapter中设置了MaxLifecycle，此时的懒加载方案和ViewPager在Androidx下的懒加载方案一致。</p>
<p>而当OffscreenPageLimit值为-1时，不存在预加载的情况，所以就不需要进行懒加载处理</p>
]]></content>
  </entry>
  <entry>
    <title>RxJava</title>
    <url>/2022/02/21/RxJava/</url>
    <content><![CDATA[<h3 id="创建被观察者"><a href="#创建被观察者" class="headerlink" title="创建被观察者"></a>创建被观察者</h3><h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>Observable是一个抽象类，实现了ObservableSource接口</p>
<a id="more"></a>

<h4 id="ObservableSource"><a href="#ObservableSource" class="headerlink" title="ObservableSource"></a>ObservableSource</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subscribes the given Observer to this ObservableSource instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer the Observer, not null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> observer&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObservableSource接口中只有一个subscribe方法。</p>
<h4 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable#create()"></a>Observable#create()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="observableOnSubscribe接口"><a href="#observableOnSubscribe接口" class="headerlink" title="observableOnSubscribe接口"></a>observableOnSubscribe接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数source传入ObservableCreate的构造方法中创建ObservableCreate类型对象，并将该对象传入RxJavaPlugins.onAssembly（Observable<T> source）中</p>
<h4 id="ObservableCreate"><a href="#ObservableCreate" class="headerlink" title="ObservableCreate"></a>ObservableCreate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，ObservableCreate的构造函数仅仅是将传入的参数赋值给成员变量进行保存。</p>
<h4 id="RxJavaPlugins-onAssembly"><a href="#RxJavaPlugins-onAssembly" class="headerlink" title="RxJavaPlugins#onAssembly()"></a>RxJavaPlugins#onAssembly()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Calls the associated hook function</span></span><br><span class="line">        Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> apply(f, source);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可见，在一般情况下，这个方法仅仅是将参数返回。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>至此，我们已经知道了创建被观察者的代码流程。在create方法中，传入的是ObservableOnSubscribe接口的实现，该接口只有一个方法。而返回的是Observable的子类，实际上也就是ObservableCreate对象。</strong></p>
<p><strong>可以发现，在这里使用了适配器模式。将ObservableOnSubscribe的实现传入ObservableCreate类中，使其转换为目标类，且同时增添了功能。单从增加功能这一个角度看，很像装饰模式，但是装饰模式的前提是不改变接口。而从ObservableOnSubscribe接口到ObservableCreate类的转换已经将接口改变了，所以不符合装饰模式的定义，而是更加符合适配器模式，即在不改变原先代码的前提下，使得现有的代码适配新的接口。</strong></p>
<h3 id="订阅过程"><a href="#订阅过程" class="headerlink" title="订阅过程"></a>订阅过程</h3><p>具体逻辑是：被观察者调用subscribe方法订阅，这时应先传入观察者。然后被观察者会调用观察者的onSubscribe方法通知观察者订阅成功，同时，被观察者也会调用我们自己实现的ObservableOnSubscribe接口的subscribe方法，这个方法持有观察者的引用，可以对观察者进行操作。</p>
<p>具体实现如下：</p>
<h4 id="Observable-subscribe"><a href="#Observable-subscribe" class="headerlink" title="Observable#subscribe()"></a>Observable#subscribe()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">       ObjectHelper.requireNonNull(observer, <span class="string">&quot;observer is null&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">           ObjectHelper.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">           subscribeActual(observer);<span class="comment">//2</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           Exceptions.throwIfFatal(e);</span><br><span class="line">           <span class="comment">// can&#x27;t call onError because no way to know if a Disposable has been set or not</span></span><br><span class="line">           <span class="comment">// can&#x27;t call onSubscribe because the call might have set a Subscription already</span></span><br><span class="line">           RxJavaPlugins.onError(e);</span><br><span class="line"></span><br><span class="line">           NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;</span>);</span><br><span class="line">           npe.initCause(e);</span><br><span class="line">           <span class="keyword">throw</span> npe;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>注释1处</p>
<h4 id="RxJavaPlugins-onSubscribe"><a href="#RxJavaPlugins-onSubscribe" class="headerlink" title="RxJavaPlugins#onSubscribe()"></a>RxJavaPlugins#onSubscribe()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observer&lt;? <span class="keyword">super</span> T&gt; onSubscribe(<span class="meta">@NonNull</span> Observable&lt;T&gt; source, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">       BiFunction&lt;? <span class="keyword">super</span> Observable, ? <span class="keyword">super</span> Observer, ? extends Observer&gt; f = onObservableSubscribe;</span><br><span class="line">       <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> apply(f, source, observer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> observer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>应用了hook技术，在一般情况下，仅仅是将传入的参数返回。</p>
<p>注释2处</p>
<h4 id="Observable-subscribeActual"><a href="#Observable-subscribeActual" class="headerlink" title="Observable#subscribeActual()"></a>Observable#subscribeActual()</h4><p>这是一个抽象方法。具体的实现在Observable的子类，在本例中具体的实现在ObservableCreate类对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="ObservableCreate-subscribeActual"><a href="#ObservableCreate-subscribeActual" class="headerlink" title="ObservableCreate#subscribeActual()"></a>ObservableCreate#subscribeActual()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">      CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);<span class="comment">//1</span></span><br><span class="line">      observer.onSubscribe(parent);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          source.subscribe(parent);<span class="comment">//3</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          Exceptions.throwIfFatal(ex);</span><br><span class="line">          parent.onError(ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处</p>
<h4 id="CreateEmitter"><a href="#CreateEmitter" class="headerlink" title="CreateEmitter"></a>CreateEmitter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3434801548987643227L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> NullPointerException(<span class="string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">                RxJavaPlugins.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onError(t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onComplete();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            DisposableHelper.set(<span class="keyword">this</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(Cancellable c)</span> </span>&#123;</span><br><span class="line">            setDisposable(<span class="keyword">new</span> CancellableDisposable(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SerializedEmitter&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;%s&#123;%s&#125;&quot;</span>, getClass().getSimpleName(), <span class="keyword">super</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CreateEmitter继承了AtomicReference<Disposable>，所以保证了Disposable的一致性。</p>
<blockquote>
<p>Atomic家族主要是保证多线程环境下的原子性，相比synchronized而言更加轻量级。比较常用的是AtomicInteger，作用是对Integer类型操作的封装，而AtomicReference作用是对普通对象的封装。</p>
</blockquote>
<p>且CreateEmitter实现了ObservableEmitter<T>和 Disposable接口</p>
<p>CreateEmitter<T> parent = new CreateEmitter<T>(observer);将observer传入CreateEmitter类，为其扩展增加了事件发射的功能，但依然改变了它的接口，所以也是适配器模式。</p>
<h4 id="Disposable"><a href="#Disposable" class="headerlink" title="Disposable"></a>Disposable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dispose the resource, the operation should be idempotent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this resource has been disposed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if this resource has been disposed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注释2处</p>
<p><strong>observer.onSubscribe(parent);</strong></p>
<p>observer是Observable的subscribe调用方法subscribeActual传进来的观察者参数，实际上是我们自定义的观察者对象。</p>
<p>observer的onSubscribe也是我们自定义observer时需要实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void onSubscribe(@NonNull Disposable d);</span><br></pre></td></tr></table></figure>

<p>其参数为Disposable类型，CreateEmitter实现了Disposable接口，所以可以进一步看出，我们向CreateEmitter构造函数传入observer，使其可以适配Disposable接口。</p>
<p>该方法是在被观察者的subscribe方法里的观察者的回调方法，可以用来通知观察者订阅成功。CreateEmitter类型的参数parent，是对observer功能的扩展，使其具备一些如中断处理的功能，这样就可以在观察者收到订阅成功的消息后，进行进一步的操作。</p>
<p>注释3处</p>
<p> <strong>source.subscribe(parent)</strong></p>
<p>source也就是ObservableCreate类保存的observableOnSubscribe接口实例。</p>
<p><strong>observableOnSubscribe#subscribe</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void subscribe(@NonNull ObservableEmitter&lt;T&gt; emitter) throws Exception;</span><br></pre></td></tr></table></figure>

<p>这个方法中需要传入ObservableEmitter类型的参数，即实现了ObservableEmitter的CreateEmitter类型对象parent。</p>
<p>observableOnSubscribe的subscribe方法也是我们自己定义的，通常会在其中调用emitter.onNext（）和 emitter.onComplete（）方法。</p>
<blockquote>
<p>注意区分subscribe（）方法和onSubscribe（）方法，前者属于被观察者，后者属于观察者。</p>
</blockquote>
<p>emitter.onNext（）方法具体的实现在CreateEmitter类中。</p>
<p>这里的observer就是我们在构造CreateEmitter对象时传入的我们自定义的观察者。它的onNext（）和onComplete（）方法是我们自定义观察者时实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> NullPointerException(<span class="string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            observer.onComplete();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这两个方法中都有isDisposed()的判断</p>
<h4 id="CreateEmitter-isDisposed"><a href="#CreateEmitter-isDisposed" class="headerlink" title="CreateEmitter#isDisposed()"></a>CreateEmitter#isDisposed()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="AtomicReference-get"><a href="#AtomicReference-get" class="headerlink" title="AtomicReference#get()"></a>AtomicReference#get()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们没有设置value，所以返回值为null</p>
<h4 id="DisposableHelper-isDisposed"><a href="#DisposableHelper-isDisposed" class="headerlink" title="DisposableHelper#isDisposed()"></a>DisposableHelper#isDisposed()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DisposableHelper</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The singleton instance representing a terminal, disposed state, don&#x27;t leak it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DISPOSED</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if the given Disposable is the common &#123;<span class="doctag">@link</span> #DISPOSED&#125; enum value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> d the disposable to check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if d is &#123;<span class="doctag">@link</span> #DISPOSED&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d == DISPOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此例中d == null,所以默认返回false。</p>
<p>isDisposed（）方法是用来判断当前事件是否被切断，在未进行任何设置的情况下，事件默认是不会被切断的。</p>
<p>在CreateEmitter类中，onNext()和onComplete()方法会先判断事件是否被切断，如果被切断了，就不会继续执行方法中的代码。如果事件没有被切断，onNext()和onComplete()方法会正常执行，onError()和onComplete()方法最后会执行dispose()方法。这个方法会将事件切断。</p>
<h4 id="CreateEmitter-dispose"><a href="#CreateEmitter-dispose" class="headerlink" title="CreateEmitter#dispose()"></a>CreateEmitter#dispose()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="DisposableHelper-dispose"><a href="#DisposableHelper-dispose" class="headerlink" title="DisposableHelper#dispose()"></a>DisposableHelper#dispose()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dispose</span><span class="params">(AtomicReference&lt;Disposable&gt; field)</span> </span>&#123;</span><br><span class="line">        Disposable current = field.get();</span><br><span class="line">        Disposable d = DISPOSED;</span><br><span class="line">        <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">            current = field.getAndSet(d);</span><br><span class="line">            <span class="keyword">if</span> (current != d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="AtomicReference-getAndSet"><a href="#AtomicReference-getAndSet" class="headerlink" title="AtomicReference#getAndSet()"></a>AtomicReference#getAndSet()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicReference的getAndSet方法通过调用unsafe类的getAndSetObject的CAS操作，保证了操作的原子性，解决了并发操作的读写问题。</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>线程切换主要分为subscribeOn()和observeOn()方法</p>
<h4 id="Observable-subscribeOn"><a href="#Observable-subscribeOn" class="headerlink" title="Observable#subscribeOn()"></a>Observable#subscribeOn()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对上面讲过的内容有印象，可以发现，这个方法和Observable的create方法的结构和形式十分相似。</p>
<p>这里需要传入Scheduler类型的参数。我们通常通过Schedulers类来获取Scheduler类型的子类。</p>
<p>常见的Scheduler类型如下</p>
<table>
<thead>
<tr>
<th>Scheduler类型</th>
<th>使用方式</th>
<th>含义</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>IoScheduler</td>
<td><code>Schedulers.io()</code></td>
<td>io操作线程</td>
<td>读写SD卡文件，查询数据库，访问网络等IO密集型操作</td>
</tr>
<tr>
<td>NewThreadScheduler</td>
<td><code>Schedulers.newThread()</code></td>
<td>创建新线程</td>
<td>耗时操作等</td>
</tr>
<tr>
<td>SingleScheduler</td>
<td><code>Schedulers.single()</code></td>
<td>单例线程</td>
<td>只需一个单例线程时</td>
</tr>
<tr>
<td>ComputationScheduler</td>
<td><code>Schedulers.computation()</code></td>
<td>CPU计算操作线程</td>
<td>图片压缩取样、xml,json解析等CPU密集型计算</td>
</tr>
<tr>
<td>TrampolineScheduler</td>
<td><code>Schedulers.trampoline()</code></td>
<td>当前线程</td>
<td>需要在当前线程立即执行任务时</td>
</tr>
<tr>
<td>HandlerScheduler</td>
<td><code>AndroidSchedulers.mainThread()</code></td>
<td>Android主线程</td>
<td>更新UI等</td>
</tr>
</tbody></table>
<p>Schedulers.io()是我们常用的调度器类型，所以接下来看一下它的具体实现  </p>
<h4 id="Schedulers-io"><a href="#Schedulers-io" class="headerlink" title="Schedulers#io()"></a>Schedulers#io()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> RxJavaPlugins.onIoScheduler(IO);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Schedulers-IO"><a href="#Schedulers-IO" class="headerlink" title="Schedulers#IO"></a>Schedulers#IO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    IO = RxJavaPlugins.initIoScheduler(<span class="keyword">new</span> IOTask())；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Schedulers-IOTask"><a href="#Schedulers-IOTask" class="headerlink" title="Schedulers#IOTask"></a>Schedulers#IOTask</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Scheduler</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IoHolder.DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Schedulers-IoHolder-DEFAULT"><a href="#Schedulers-IoHolder-DEFAULT" class="headerlink" title="Schedulers#IoHolder.DEFAULT"></a>Schedulers#IoHolder.DEFAULT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IoHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> IoScheduler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RxJavaPlugins主要是执行一些hook操作，可以忽视。</p>
<p>所以Schedulers.io()实际是返回了一个IoScheduler类型的对象。</p>
<p>注释1处</p>
<p><strong>new ObservableSubscribeOn<T>(this, scheduler)</strong></p>
<h4 id="ObservableSubscribeOn"><a href="#ObservableSubscribeOn" class="headerlink" title="ObservableSubscribeOn"></a>ObservableSubscribeOn</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure>

<p>在Observable的subscribeOn方法中，将其自身传入ObservableSubscribeOn方法作为第一个参数。因为Observable实现了ObservableSource接口。</p>
<p>**super(source)**是调用父类构造函数，将source保存在父类的成员变量中。</p>
<p>可以看到这个ObservableSubscribeOn类存储了调度器的类型，以及ObservableSource接口的实例。</p>
<p>最开始有讲过RxJavaPlugins.onAssembly()方法，它需要接收一个Observable类型的对象。而ObservableSubscribeOn类也是Observable的子类，所以可以将ObservableSubscribeOn类型的对象传入RxJavaPlugins.onAssembly()方法中。一般情况下，RxJavaPlugins.onAssembly()方法只是将传入的参数返回。</p>
<p>Observable.subscribeOn()方法返回的是一个ObservableSubscribeOn类型的对象。它也是Observable的子类。</p>
<p><strong>所以，我们可以用它调用subscribe()订阅方法。它的具体实现在Observable类中。之前已经讲过。</strong></p>
<p>但与之前不同的是，这个方法中调用的这个方法：**<em>subscribeActual(observer);**</em>，它的具体实现要交由子类完成，而在这里，实际是调用了ObservableSubscribeOn类的该方法。</p>
<h4 id="ObservableSubscribeOn-subscribeActual"><a href="#ObservableSubscribeOn-subscribeActual" class="headerlink" title="ObservableSubscribeOn#subscribeActual()"></a>ObservableSubscribeOn#subscribeActual()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    observer.onSubscribe(parent);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubscribeOnObserver是ObservableSubscribeOn的内部类</p>
<h4 id="SubscribeOnObserver"><a href="#SubscribeOnObserver" class="headerlink" title="SubscribeOnObserver"></a>SubscribeOnObserver</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8094547886072529208L</span>;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AtomicReference&lt;Disposable&gt; upstream;</span><br><span class="line"></span><br><span class="line">    SubscribeOnObserver(Observer&lt;? <span class="keyword">super</span> T&gt; downstream) &#123;</span><br><span class="line">        <span class="keyword">this</span>.downstream = downstream;</span><br><span class="line">        <span class="keyword">this</span>.upstream = <span class="keyword">new</span> AtomicReference&lt;Disposable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        DisposableHelper.setOnce(<span class="keyword">this</span>.upstream, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        downstream.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        downstream.onError(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        downstream.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DisposableHelper.dispose(upstream);</span><br><span class="line">        DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        DisposableHelper.setOnce(<span class="keyword">this</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个类和CreateEmitter类形式很相似。但最大的区别是，这个类具有AtomicReference<Disposable>类型名为upstream的成员变量。而CreateEmitter类是不具有的。因为正常情况下，调用CreateEmitter类对象的地方，便是最上游。</p>
<p>注释2</p>
<p><strong>observer.onSubscribe(parent)</strong></p>
<p>依然是一个回调方法。可以通知观察者订阅成功</p>
<p>注释3</p>
<p><strong>parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</strong></p>
<p>这里的逻辑较为复杂，先给出一个结论，它最后会执行SubscribeTask类的run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>要理解 source.subscribe(parent)，先要理解下面具体流程的逻辑图：</p>
<p><img src="https://i.loli.net/2021/11/20/bkgAWwvBIMaZKUe.png" alt="未命名文件 (22).png"></p>
<p>注意区分，ObservableSubscribeOn的成员变量source指的是ObservableCreate对象，而ObservableCreate对象也有一个成员变量source，这个source指的是Observable在create时传进来的我们自定义的ObservableOnSubscribe。</p>
<p>ObservableSubscribeOn和ObservableCreate都没有重写subscribe方法，所以我们在调用subscribe时，其实会调用从Observable类继承来的subscribe方法。</p>
<p>这样看来，其实有点像递归操作，在一个方法中调用它本身。</p>
<p>但这个递归应该是有出口的，否则它就是一个死循环。那它的出口是什么呢？其实就是当source为我们实例的ObservableOnSubscribe接口。因为ObservableOnSubscribe中也有subscribe方法，我们无需再去调用Observable的subscribe方法，而是调用我们自定义的subscribe方法。</p>
<p>所以图中的1处，还会调用Observable的subscribe方法，直到碰到source为ObservableOnSubscribe时，便可以不再调用Observable的subscribe方法，即图中的2处。</p>
<p>ObservableSubscribeOn中持有Scheduler类型的成员变量，它将会在subscribeActual()方法的最后执行线程的切换操作。即source.subscribe(parent);会在Scheduler指定的线程中执行。这就是为什么subscribeOn()可以改变被观察者发送消息的线程。</p>
<h4 id="若我们多次调用subscribeOn-方法会出现什么情况？"><a href="#若我们多次调用subscribeOn-方法会出现什么情况？" class="headerlink" title="若我们多次调用subscribeOn()方法会出现什么情况？"></a>若我们多次调用subscribeOn()方法会出现什么情况？</h4><p>由于每一个ObservableSubscribeOn中持有Scheduler类型的成员变量，所以它的subscribeActual()方法会根据Scheduler进行相应的线程切换。</p>
<p>图中的圆圈1，2表示线程1，2。</p>
<p>最外层的ObservableSubscribeOn（即拥有线程2的对象）执行subscribe方法时，会将线程切换到线程2，然后继续调用倒数第二层ObservableSubscribeOn方法，依次类推，它也会执行subscribe方法时，会将线程切换到线程1。然后继续执行倒数第三层的ObservableCreate的subscribe方法。但ObservableCreate不持有Scheduler类对象，也不会对线程进行切换，所以，此时的线程为线程1。</p>
<p>所以多次调用subscribeOn()方法，只有第一个subscribeOn()会对被观察者造成影响，其他的subscribeOn()也会造成线程切换，只是使用者感受不到。</p>
<p><img src="https://i.loli.net/2021/11/20/3mLhAu7XUQwEvnY.png" alt="未命名1.png"></p>
<p><strong>subscribeOn()只影响其最近上游所在的线程。</strong></p>
<p><strong>它主要影响的是自定义被观察者的subscribe方法。</strong></p>
<h4 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h4><p>doOnSubscribe()方法执行所在线程由其后面的subscribeOn()来指定；若没有subscribeOn()指定，则执行的线程和本身所在线程一致。</p>
<p>它和subscribeOn方法执行逻辑很像，只是它不会切换线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">doOnSubscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doOnLifecycle(onSubscribe, Functions.EMPTY_ACTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>subscribeOn 作用于该操作符之前的 Observable 的创建操符作以及 doOnSubscribe 操作符</strong> ，换句话说就是 <strong>doOnSubscribe 以及 Observable 的创建操作符总是被其之后最近的 subscribeOn 控制</strong></p>
<h4 id="Observable-observeOn"><a href="#Observable-observeOn" class="headerlink" title="Observable#observeOn()"></a>Observable#observeOn()</h4><p>通常用第一个方法，向其中传入调度器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observeOn(scheduler, delayError, bufferSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">        ObjectHelper.verifyPositive(bufferSize, <span class="string">&quot;bufferSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，最终会将其传入ObservableObserveOn中保存</p>
<h4 id="ObservableObserveOn-subscribe"><a href="#ObservableObserveOn-subscribe" class="headerlink" title="ObservableObserveOn#subscribe"></a>ObservableObserveOn#subscribe</h4><p>它的subscribe逻辑和之前提到的ObservableSubscribeOn的subscribe逻辑很像。都会先调用Observable的subscribe方法。而对于subscribeActual方法，不同Observable子类有不同逻辑。</p>
<h4 id="ObservableObserveOn-subscribeActual"><a href="#ObservableObserveOn-subscribeActual" class="headerlink" title="ObservableObserveOn#subscribeActual"></a>ObservableObserveOn#subscribeActual</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        source.subscribe(observer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));</strong></p>
<p>主要是将observer进行进一步的传递与保存。</p>
<p>然后就是调用source（在这里也就是ObservableCreate）的subscribe方法。这个流程和前面讲过的一样。继续将observer进行进一步的传递与保存。</p>
<p>最终会调用自定义被观察者的subscribe方法。在这个方法中，假设我们调用了observer的onNext()方法。将会对之前进行层层包裹的observer进行调用。</p>
<p>首先，将会调用CreateEmitter的onNext()方法</p>
<h4 id="CreateEmitter-onNext"><a href="#CreateEmitter-onNext" class="headerlink" title="CreateEmitter#onNext()"></a>CreateEmitter#onNext()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onError(<span class="keyword">new</span> NullPointerException(<span class="string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，会调用它保存的observer的onNext(),在此处是ObserveOnObserver的onNext()</p>
<h4 id="ObserveOnObserver-onNext"><a href="#ObserveOnObserver-onNext" class="headerlink" title="ObserveOnObserver#onNext()"></a>ObserveOnObserver#onNext()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法较为复杂。结果是它会先切换线程，然后调用它保存的observer的onNext()。此处也就是调用我们自定义的observer的onNext()。</p>
<p>这个过程的具体流程图如下：</p>
<p><img src="https://i.loli.net/2021/11/22/EqNmyAlTjiwXrk9.png" alt="2 (1).png"></p>
<h4 id="若我们多次调用observeOn-方法会出现什么情况？"><a href="#若我们多次调用observeOn-方法会出现什么情况？" class="headerlink" title="若我们多次调用observeOn()方法会出现什么情况？"></a>若我们多次调用observeOn()方法会出现什么情况？</h4><p>相比一次调用observeOn()，多次调用只是进行了更多的线程切换，但只有离自定义的observe最近的会对它造成影响。</p>
<p><img src="https://i.loli.net/2021/11/23/VZKAp5QGOInuCyT.png" alt="2 (2).png"></p>
<h2 id="Retrofit与RxJava"><a href="#Retrofit与RxJava" class="headerlink" title="Retrofit与RxJava"></a>Retrofit与RxJava</h2><p>RxJava和Retrofit的组合是安卓开发里很常用的网络请求方法。</p>
<p>基本用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Api service = retrofit.create(Api.class);</span><br><span class="line">Observable&lt;Msg&gt; observable = service.getMsg();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">observable.subscribeOn(Schedulers.io()) </span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Msg&gt;() &#123; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>这里的observable是CallExecuteObservable类型的。作为Observable的子类，我们依旧关注它对subscribeActual方法的实现。</p>
<h3 id="CallExecuteObservable-subscribeActual"><a href="#CallExecuteObservable-subscribeActual" class="headerlink" title="CallExecuteObservable#subscribeActual()"></a>CallExecuteObservable#subscribeActual()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Response&lt;T&gt;&gt; observer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Since Call is a one-shot type, clone it for each new observer.</span></span><br><span class="line">  Call&lt;T&gt; call = originalCall.clone();</span><br><span class="line">  CallDisposable disposable = <span class="keyword">new</span> CallDisposable(call);</span><br><span class="line">  observer.onSubscribe(disposable);</span><br><span class="line">  <span class="keyword">if</span> (disposable.isDisposed()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response&lt;T&gt; response = call.execute();<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">      observer.onNext(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">      terminated = <span class="keyword">true</span>;</span><br><span class="line">      observer.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    Exceptions.throwIfFatal(t);</span><br><span class="line">    <span class="keyword">if</span> (terminated) &#123;</span><br><span class="line">      RxJavaPlugins.onError(t);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!disposable.isDisposed()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        observer.onError(t);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable inner) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(inner);</span><br><span class="line">        RxJavaPlugins.onError(<span class="keyword">new</span> CompositeException(t, inner));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注释1"><a href="#注释1" class="headerlink" title="注释1"></a>注释1</h4><p><strong>Response<T> response = call.execute();</strong></p>
<p>又见到了熟悉的call.execute()，这个是我们在不用RxJava时，常用的开启网络请求的方法。它只是被包装在Observable中，最终还是会被调用来进行网络请求。</p>
<p>TODO:适配器or装饰模式</p>
]]></content>
  </entry>
  <entry>
    <title>RxJava的流控</title>
    <url>/2022/02/21/%E8%83%8C%E5%8E%8B/</url>
    <content><![CDATA[<h1 id="FlowControl-流控"><a href="#FlowControl-流控" class="headerlink" title="FlowControl(流控)"></a>FlowControl(流控)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在RxJava中，遇到这样一种情况并不困难:Observable发出条目的速度比操作符或订阅者消费它们的速度要快。这就提出了一个问题，即如何处理这种不断增长的未消耗项目的积压。</p>
<a id="more"></a>

<p>例如，想象一下使用zip操作符将两个无限的observable压缩到一起，其中一个发出条目的频率是另一个的两倍。zip操作符的幼稚实现将不得不维护一个不断扩展的缓冲区，以保存由更快的Observable发出的项，最终与由更慢的Observable发出的项合并。这会导致RxJava占用大量的系统资源。</p>
<p>在RxJava中，您可以使用多种策略来实施流量控制和反压，以缓解快速生成的Observable遇到缓慢消耗的观察者时所造成的问题。本页面解释了其中一些策略，并向您展示了如何设计自己的Observable和Observable操作符来满足流量控制的请求</p>
<h2 id="Hot-and-cold-Observables-and-multicasted-Observables"><a href="#Hot-and-cold-Observables-and-multicasted-Observables" class="headerlink" title="Hot and cold Observables, and multicasted Observables"></a>Hot and cold Observables, and multicasted Observables</h2><p>cold Observable发射一个特定的项目序列，但当其Observer觉得方便时，可以开始发射该序列，并且以Observer希望的任何速率发射，而不会破坏序列的完整性。例如，如果您将静态Iterable转换为Observable，则该Observable将发出相同的项序列，无论稍后何时以何频率订阅或观察这些项。cold Observable的示例主要包括数据库查询、文件检索。</p>
<p>A hot Observable 在创建时开始生成要立即发射的项。Observer通常开始观察从序列中间的某个地方观察到的热点发出的项目序列，从在订阅建立之后可观察到的第一个项目开始。Observable以其自身的速度发射消息。对消息的接收情况取决于它的观察者能否跟上。A hot Observable示例主要包括鼠标和键盘事件、系统事件或股票价格</p>
<p>当a cold Observable是multicast时（当它被转换为ConnectableObservable并调用其connect（）方法时），它实际上变为a hot Observable，并且出于反压和流量控制的目的，它应该被视为a hot Observable。</p>
<p>Cold Observables 是一种理想的模型，它很少出现上游流速远大于下游消费速度的问题。Hot Observables通常不能很好地处理反压的情况。</p>
<p>所以Hot Observables更适合用下文讲述的onBackpressureBuffer或onBackpressureDrop操作符、节流、缓冲或窗口等来处理反压问题。</p>
<h1 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h1><p>Backpressure常被翻译为背压，但我觉得翻译成反压更加形象。</p>
<p>Backpressure可以理解为将消费者的压力反馈给生产者，这就是反压的含义。</p>
<h1 id="使用一些操作符代替反压"><a href="#使用一些操作符代替反压" class="headerlink" title="使用一些操作符代替反压"></a>使用一些操作符代替反压</h1><p>应对Observable生产过剩问题的第一道防线是使用一些普通的Observable操作符集合，将发出的项的数量减少到一个更易于管理的数量。</p>
<p>本节的例子将展示如何使用这些操作符来处理一个数据突发式的Observable，就像下面的图中所示的那样:</p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.bursty.png" alt="img"></p>
<p>通过微调这些操作符的参数，你可以确保一个慢速消耗的观察者不会被一个快速生成的Observable所淹没。</p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>像sample()或throttleLast()、throttleFirst()和throttleWithTimeout()或debounce()这样的操作符允许你调节Observable发出条目的速率。</p>
<p>它不是限制发送的数量，而是对发送的内容进行选择性接收，没有被接收的则丢弃。</p>
<blockquote>
<p>以下的bursty为自定义的Observable子类</p>
<p>所以这些操作符是用于限制Observable的发送，或者说限制对Observe的onNext方法的调用时机。</p>
</blockquote>
<h4 id="sample-or-throttleLast"><a href="#sample-or-throttleLast" class="headerlink" title="sample (or throttleLast)"></a>sample (or throttleLast)</h4><h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; burstySampled = bursty.sample(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><p>根据用户设置的时间间隔，隔一段时间去发送一次数据，所发送的数据为这个时间间隔内，最后发送的数据。所以无论这个时间间隔内产生了多少数据，观察者只接收到最后一个。</p>
<h5 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h5><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.sample.png" alt="img"></p>
<p>下图中，用黄色和蓝色高光表示的是时间的间隔。在这段时间间隔内发送的最后一个数据即为观察者收到的数据。</p>
<p><img src="https://i.loli.net/2021/12/02/Bgmqktl45AzpcDQ.jpg" alt="IMG_0660(20211202-213543).PNG"></p>
<h4 id="throttleFirst"><a href="#throttleFirst" class="headerlink" title="throttleFirst"></a>throttleFirst</h4><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; burstyThrottled = bursty.throttleFirst(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<h5 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h5><p>与上面说的sample (or throttleLast)相反，它发送的是一段时间间隔内的第一个数据</p>
<h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.throttleFirst.png" alt="img"></p>
<h4 id="debounce-or-throttleWithTimeout"><a href="#debounce-or-throttleWithTimeout" class="headerlink" title="debounce (or throttleWithTimeout)"></a>debounce (or throttleWithTimeout)</h4><h5 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; burstyDebounced = bursty.debounce(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<h5 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h5><p>只发出Observable中在指定的持续时间内后面没有其他item的那些消息</p>
<h5 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h5><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.debounce.png" alt="img"></p>
<p>图中粉色高亮的部分，为大于设置的时间间隔的一段时间，在这段时间前的最后一个消息，即为要发送的消息。也就是说，在一定的时间间隔内，将要发送的消息后面没有其他消息。</p>
<p><img src="https://s2.loli.net/2021/12/04/EVwy6b9xDN7Qgnr.jpg" alt="IMG_0664(20211204-211630).PNG"></p>
<h3 id="打包发送"><a href="#打包发送" class="headerlink" title="打包发送"></a>打包发送</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>可以使用像buffer()或window()这样的操作符来从Observable中收集消息，然后将它们以集合(或Observable)的形式发出。然后，速度慢的使用者可以决定是只处理每个集合中的一个特定消息，还是处理这些消息的某些组合，还是根据需要安排对集合中的每个消息执行的工作。</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><h5 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<h5 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h5><p>在有规律的时间间隔内，周期性地关闭并从突发的Observable中发送一个条目缓冲区的消息</p>
<blockquote>
<p>打包后的消息是用List存储起来</p>
</blockquote>
<h5 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h5><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer2.png" alt="img"></p>
<h5 id="进一步使用"><a href="#进一步使用" class="headerlink" title="进一步使用"></a>进一步使用</h5><h5 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// we have to multicast the original bursty Observable so we can use it</span></span><br><span class="line"><span class="comment">// both as our source and as the source for our buffer closing selector:</span></span><br><span class="line">Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();</span><br><span class="line"><span class="comment">// burstyDebounced will be our buffer closing selector:</span></span><br><span class="line">Observable&lt;Integer&gt; burstyDebounced = burstMulticast.debounce(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="comment">// and this, finally, is the Observable of buffers we&#x27;re interested in:</span></span><br><span class="line">Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</span><br></pre></td></tr></table></figure>

<h5 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h5><p>将buffer和之前提到的debounce结合。</p>
<p>首先用户设置一段时间间隔。</p>
<p>在一个缓冲区后面若间隔了设置的时间依然没有消息，则将这个缓冲区的消息一起发送。</p>
<h5 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h5><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.buffer1.png" alt="img"></p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><h5 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h5><p>将一段连续的消息打包成新的Observable发送。</p>
<p>一段消息的长度确定有两种方式：一段时间间隔内的所有消息，或者自行设置一段消息中共有多少消息。</p>
<h5 id="时间间隔内的消息图示"><a href="#时间间隔内的消息图示" class="headerlink" title="时间间隔内的消息图示"></a>时间间隔内的消息图示</h5><p>在用户设置的时间间隔内的所有消息被打包成一个新的Observable进行发送</p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window1.png" alt="img"></p>
<h6 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>



<h5 id="自定义数量消息的图示"><a href="#自定义数量消息的图示" class="headerlink" title="自定义数量消息的图示"></a>自定义数量消息的图示</h5><p>自定义一次打包多少消息。在达到了设置的个数时，将会打包成新的Observable进行发送。</p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.window2.png" alt="img"></p>
<h6 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Observable&lt;Integer&gt;&gt; burstyWindowed = bursty.window(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h3 id="Callstack-blocking"><a href="#Callstack-blocking" class="headerlink" title="Callstack blocking"></a>Callstack blocking</h3><p>如果Observable、所有对它进行操作的操作符以及订阅它的观察者都在同一个线程中操作，这将通过调用Callstack blocking（堆栈阻塞）有效地建立一种形式的背压。</p>
<p>即整个调用链处于同一个线程，不能用常用的线程切换方法切换线程。这属于同步的调用。</p>
<p>所以，Observable发送的消息会被<strong>观察者</strong>按顺序接收，若观察者在接收、处理消息时过慢，便会阻塞后面的消息。</p>
<p>这种情况其实和RxJava的主要功能相违背，属于很少见的情况。</p>
<h3 id="Subscriber如何建立响应式获取的反压策略"><a href="#Subscriber如何建立响应式获取的反压策略" class="headerlink" title="Subscriber如何建立响应式获取的反压策略"></a>Subscriber如何建立响应式获取的反压策略</h3><h4 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a>思想</h4><p>当你用Subscriber订阅一个Observable时，你可以通过在Subscriber的onStart()方法中调用Subscriber.request(n)来请求响应式获取消息(n是你希望Observable在下一次request()调用之前发出的最大条目数)。</p>
<p>然后，在onNext()中处理这个消息(或这些消息)之后，您可以再次调用request()来指示Observable发出另一个消息(或多个消息)。</p>
<h4 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">someObservable.subscribe(<span class="keyword">new</span> Subscriber&lt;t&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// gracefully handle sequence-complete</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// gracefully handle error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(t n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// do something with the emitted item &quot;n&quot;</span></span><br><span class="line">      <span class="comment">// request another item:</span></span><br><span class="line">      request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> request(Long.MAX_VALUE)，可以禁用响应式获取数据，并要求Observable以自己的速度发出条目。request(0)是一个合法调用，但没有效果。将小于0的值传递给request()将导致抛出异常。</p>
</blockquote>
<h4 id="Reactive-pull-backpressure-isn’t-magic"><a href="#Reactive-pull-backpressure-isn’t-magic" class="headerlink" title="Reactive pull backpressure isn’t magic"></a>Reactive pull backpressure isn’t magic</h4><h5 id="onBackpressureBuffer"><a href="#onBackpressureBuffer" class="headerlink" title="onBackpressureBuffer"></a>onBackpressureBuffer</h5><h6 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a>思想</h6><p>维护Observable的所有发射的缓冲区，并根据Subscribers生成的requests将数据发送给它们。</p>
<h6 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h6><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.obp.buffer.png" alt="img"></p>
<p>图中虚线部分是原先缓冲区的消息，每次Subscribers进行request(n)时，都会将缓冲区的前n个消息发送给Subscribers</p>
<p>所以在进行了五次request(1)后，原先缓冲区中前五个红色的消息就被发送给Subscribers了。</p>
<p><img src="https://s2.loli.net/2021/12/05/jmyGbUSJdN5fszP.jpg" alt="IMG_0668(20211205-193751).PNG"></p>
<blockquote>
<p>这个操作符的一个实验版本（RxJava 1.0中不可用）允许您设置缓冲区的容量；如果缓冲区溢出，应用此运算符将导致生成的Observable终止并出现错误</p>
</blockquote>
<h5 id="onBackpressureDrop"><a href="#onBackpressureDrop" class="headerlink" title="onBackpressureDrop"></a>onBackpressureDrop</h5><h6 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a>思想</h6><p>在收到request(n)请求后，将这个请求之后产生的n条消息发送给Subscribers。其余的不属于这个范围的消息都将会被丢弃。</p>
<h6 id="图示-5"><a href="#图示-5" class="headerlink" title="图示"></a>图示</h6><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.obp.drop.png" alt="img"></p>
<p>即将图中蓝色虚线之后的一条消息发送给Subscribers</p>
<p><img src="https://s2.loli.net/2021/12/05/RaCpeDNqQ3Z9wis.jpg" alt="IMG_0670(20211205-195733).PNG"></p>
<h5 id="onBackpressureLatest"><a href="#onBackpressureLatest" class="headerlink" title="onBackpressureLatest"></a>onBackpressureLatest</h5><h6 id="思想-9"><a href="#思想-9" class="headerlink" title="思想"></a>思想</h6><p>默认会缓存最新的n条数据，当接收到request(n)的时候，会把缓存的数据发送给Subscribers</p>
<h6 id="图示-6"><a href="#图示-6" class="headerlink" title="图示"></a>图示</h6><p><img src="http://zhangtielei.com/assets/photos_rxjava/backpressure/bp.obp.latest.png" alt="sample"></p>
<h5 id="onBackpressureBlock"><a href="#onBackpressureBlock" class="headerlink" title="onBackpressureBlock"></a>onBackpressureBlock</h5><h6 id="思想-10"><a href="#思想-10" class="headerlink" title="思想"></a>思想</h6><p>调用onBackpressureBlock（n）时传入的参数n，在Observable产生了n条未被Subscribers进行request的数据后，Observable所在的线程将被阻塞，直到Subscribersr进行request（x）的操作，此时Observable所在的线程将不被阻塞，Observable又可以生成x条数据。</p>
<p>简而言之，在Observable生成了n条未被消费的消息后，它所在的线程将被阻塞。</p>
<h6 id="图示-7"><a href="#图示-7" class="headerlink" title="图示"></a>图示</h6><p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/bp.obp.block.png" alt="img"></p>
<p>由于这里onBackpressureBlock传入的参数是2，所以Observable在生成了2条未被消费的消息后，所在线程将被阻塞。</p>
<p>图中，刚开始生成了2个红色的1和2，所以Observable所在线程被block。直到Subscribers进行了request（1），获得了两个数据的第一个，即红色的1，所以Observable中只有红色的2，所在线程被unblock，之后又生产了一个橙色的1，现有红色的2和橙色的1，直到Subscribers进行了request（1）后进行如上重复操作。<img src="https://s2.loli.net/2021/12/05/Wo9caksqSJGOxTz.jpg" alt="IMG_0676(20211205-205825).PNG"></p>
<blockquote>
<p>可以理解为堵住了接收者的接收入口</p>
</blockquote>
<h2 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h2><h3 id="Observable-与-Flowable"><a href="#Observable-与-Flowable" class="headerlink" title="Observable 与 Flowable"></a>Observable 与 Flowable</h3><p>在RxJava的前一个版本中，只有一个基类用于处理反压和非反压的情况——Observable</p>
<p>而RxJava 2引入了Flowable来处理反压的情况。</p>
<h3 id="Flowable的创建"><a href="#Flowable的创建" class="headerlink" title="Flowable的创建"></a>Flowable的创建</h3><h4 id="简单的Flowable"><a href="#简单的Flowable" class="headerlink" title="简单的Flowable"></a>简单的Flowable</h4><p>我们可以像创建Observable一样，使用just()方法创建一个Flowable:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; integerFlowable = Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>尽管just()的使用非常简单，但从静态数据创建一个Flowable并不常见，它仅仅用于测试。</p>
<h4 id="通过Observable创建Flowable"><a href="#通过Observable创建Flowable" class="headerlink" title="通过Observable创建Flowable"></a>通过Observable创建Flowable</h4><p>当我们有一个Observable时，我们可以很容易地使用toFlowable()方法将其转换为Flowable:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable&lt;Integer&gt; integerObservable = Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Flowable&lt;Integer&gt; integerFlowable = integerObservable</span><br><span class="line">  .toFlowable(BackpressureStrategy.BUFFER);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的BackpressureStrategy将会在下文讲述</p>
</blockquote>
<h4 id="通过FlowableOnSubscribe创建Flowable"><a href="#通过FlowableOnSubscribe创建Flowable" class="headerlink" title="通过FlowableOnSubscribe创建Flowable"></a>通过FlowableOnSubscribe创建Flowable</h4><p>RxJava 2引入了一个接口FlowableOnSubscribe，它表示一个在用户订阅后开始发出事件的Flowable。</p>
<p>因此，所有客户端都将收到相同的事件集，这使得FlowableOnSubscribe反压更加安全。</p>
<p>当我们有了FlowableOnSubscribe，我们可以使用它来创建Flowable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FlowableOnSubscribe&lt;Integer&gt; flowableOnSubscribe</span><br><span class="line"> = flowable -&gt; flowable.onNext(<span class="number">1</span>);</span><br><span class="line">Flowable&lt;Integer&gt; integerFlowable = Flowable</span><br><span class="line">  .create(flowableOnSubscribe, BackpressureStrategy.BUFFER);</span><br></pre></td></tr></table></figure>



<p><strong><em>其他的创建Flowable方法这里就不一一介绍了</em></strong></p>
<h2 id="Flowable的Backpressure策略"><a href="#Flowable的Backpressure策略" class="headerlink" title="Flowable的Backpressure策略"></a>Flowable的Backpressure策略</h2><p>在RxJava 2.x中，Observable不再支持Backpressure，而是改用Flowable来专门支持Backpressure。上面提到的四种operator（<strong>onBackpressureBuffer、onBackpressureDrop、onBackpressureLatest、onBackpressureBlock</strong>）的前三种分别对应Flowable的三种Backpressure策略：</p>
<ul>
<li>BackpressureStrategy.BUFFER</li>
<li>BackpressureStrategy.DROP</li>
<li>BackpressureStrategy.LATEST</li>
</ul>
<h3 id="BackpressureStrategy"><a href="#BackpressureStrategy" class="headerlink" title="BackpressureStrategy"></a>BackpressureStrategy</h3><p>BackpressureStrategy是一个枚举类型，它定义了Flowable的反压行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents the options for applying backpressure to a source sequence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BackpressureStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * OnNext events are written without any buffering or dropping.</span></span><br><span class="line"><span class="comment">     * Downstream has to deal with any overflow.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MISSING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Signals a MissingBackpressureException in case the downstream can&#x27;t keep up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ERROR,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BUFFER,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Drops the most recent onNext value if the downstream can&#x27;t keep up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DROP,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Keeps only the latest onNext value, overwriting any previous value if the</span></span><br><span class="line"><span class="comment">     * downstream can&#x27;t keep up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LATEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><h5 id="思想-11"><a href="#思想-11" class="headerlink" title="思想"></a>思想</h5><p>如果我们使用该反压策略，source将缓冲所有事件，直到订阅者可以使用它们。也就是缓冲所有onNext()的值，直到下游使用它。</p>
<h5 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenAllValuesAreBufferedAndReceived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List testList = IntStream.range(<span class="number">0</span>, <span class="number">100000</span>)</span><br><span class="line">      .boxed()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">    Observable observable = Observable.fromIterable(testList);</span><br><span class="line">    TestSubscriber&lt;Integer&gt; testSubscriber = observable</span><br><span class="line">      .toFlowable(BackpressureStrategy.BUFFER)</span><br><span class="line">      .observeOn(Schedulers.computation()).test();</span><br><span class="line"></span><br><span class="line">    testSubscriber.awaitTerminalEvent();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; receivedInts = testSubscriber.getEvents()</span><br><span class="line">      .get(<span class="number">0</span>)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(object -&gt; (<span class="keyword">int</span>) object)</span><br><span class="line">      .boxed()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    assertEquals(testList, receivedInts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它类似于在Flowable上调用onBackpressureBuffer()方法，但它不允许指定缓冲区大小或onOverflow。</p>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><h5 id="思想-12"><a href="#思想-12" class="headerlink" title="思想"></a>思想</h5><p>我们可以用以丢弃不能消费的onNext()值，而不是缓冲它们。</p>
<p>这类似于在Flowable上使用onBackpressureDrop():</p>
<h5 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenDropStrategyUsed_thenOnBackpressureDropped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    Observable observable = Observable.fromIterable(testList);</span><br><span class="line">    TestSubscriber&lt;Integer&gt; testSubscriber = observable</span><br><span class="line">      .toFlowable(BackpressureStrategy.DROP)</span><br><span class="line">      .observeOn(Schedulers.computation())</span><br><span class="line">      .test();</span><br><span class="line">    testSubscriber.awaitTerminalEvent();</span><br><span class="line">    List&lt;Integer&gt; receivedInts = testSubscriber.getEvents()</span><br><span class="line">      .get(<span class="number">0</span>)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(object -&gt; (<span class="keyword">int</span>) object)</span><br><span class="line">      .boxed()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    assertThat(receivedInts.size() &lt; testList.size());</span><br><span class="line">    assertThat(!receivedInts.contains(<span class="number">100000</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Latest"><a href="#Latest" class="headerlink" title="Latest"></a>Latest</h4><h5 id="思想-13"><a href="#思想-13" class="headerlink" title="思想"></a>思想</h5><p>使将强制source仅保留最新的onNext()值。因此如果消费者不能跟上，将覆盖以前的任何值</p>
<h5 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenLatestStrategyUsed_thenTheLastElementReceived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    Observable observable = Observable.fromIterable(testList);</span><br><span class="line">    TestSubscriber&lt;Integer&gt; testSubscriber = observable</span><br><span class="line">      .toFlowable(BackpressureStrategy.LATEST)</span><br><span class="line">      .observeOn(Schedulers.computation())</span><br><span class="line">      .test();</span><br><span class="line"></span><br><span class="line">    testSubscriber.awaitTerminalEvent();</span><br><span class="line">    List&lt;Integer&gt; receivedInts = testSubscriber.getEvents()</span><br><span class="line">      .get(<span class="number">0</span>)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(object -&gt; (<span class="keyword">int</span>) object)</span><br><span class="line">      .boxed()</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    assertThat(receivedInts.size() &lt; testList.size());</span><br><span class="line">    assertThat(receivedInts.contains(<span class="number">100000</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>BackpressureStrategy.LATEST和BackpressureStrategy.DROP看起来非常相似。<br>但是，BackPressureStragey.LATEST将覆盖订阅者无法处理的元素，并仅保留最新的元素。<br>BackpressureStragy.DROP将丢弃无法处理的元素。这意味着不一定会发射最新的元素。</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><h5 id="思想-14"><a href="#思想-14" class="headerlink" title="思想"></a>思想</h5><p>当我们使用backpressureStragy.ERROR时，表示我们不希望出现反压。因此，如果消费者无法跟上source，则应抛出MissingBackpressureException</p>
<h5 id="使用方法-10"><a href="#使用方法-10" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenErrorStrategyUsed_thenExceptionIsThrown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable observable = Observable.range(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line">    TestSubscriber subscriber = observable</span><br><span class="line">      .toFlowable(BackpressureStrategy.ERROR)</span><br><span class="line">      .observeOn(Schedulers.computation())</span><br><span class="line">      .test();</span><br><span class="line"></span><br><span class="line">    subscriber.awaitTerminalEvent();</span><br><span class="line">    subscriber.assertError(MissingBackpressureException.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Missing"><a href="#Missing" class="headerlink" title="Missing"></a>Missing</h4><h5 id="思想-15"><a href="#思想-15" class="headerlink" title="思想"></a>思想</h5><p>source在不丢弃或缓冲的情况下发送消息。</p>
<p>在这种情况下，下游必须处理溢出</p>
<h5 id="使用方法-11"><a href="#使用方法-11" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenMissingStrategyUsed_thenException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable observable = Observable.range(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line">    TestSubscriber subscriber = observable</span><br><span class="line">      .toFlowable(BackpressureStrategy.MISSING)</span><br><span class="line">      .observeOn(Schedulers.computation())</span><br><span class="line">      .test();</span><br><span class="line">    subscriber.awaitTerminalEvent();</span><br><span class="line">    subscriber.assertError(MissingBackpressureException.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们的测试中，我们正在为ERROR和MISSING策略排除MissingbackpressureException。因为当source的内部缓冲区溢出时，它们都会抛出此类异常。然而它们有不同的目的。</p>
<p>当我们根本不期望出现反压，并且希望源程序在发生反压时抛出异常时，我们应该使用ERROR策略。</p>
<p>如果我们不想在创建Flowable时指定默认行为，可以使用MISSING策略。我们之后会用反压运算符来给它的行为赋值。</p>
]]></content>
  </entry>
  <entry>
    <title>Retrofit中的设计模式</title>
    <url>/2022/02/21/Retrofit%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>首先看一下create()方法的使用流程</p>
<p>我们需要根据自己的需要创建要进行的网络请求的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyApi</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path(&quot;user&quot;)</span> String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后将这个接口类传给retrofit.create()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyApi api = retrofit.create(MyApi.class);</span><br></pre></td></tr></table></figure>

<p>接着，我们就可以根据这个对象去调用它的网络请求方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; list = api.listRepos(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>观察上面的代码，可以发现，进行create()操作时，我们需要传入一个接口类。但在运行前，retrofit是不知道我们要传入什么样的接口类的，所以其实retrofit也应该不知道create方法该返回什么样的对象。</p>
<p>但实际上，retrofit不仅知道该返回什么对象，还知道该对象具有的方法，以及方法上的注解（如@GET）和参数等。</p>
<p>一般来说，如果想要动态获取类的对象，我们是可以用反射来实现的。</p>
<p>但是这里是要获取接口的实例，我们不能通过简单的反射方法（new实例）实现，因为这是个接口，没有构造器。</p>
<p>所以我们需要使用代理的方法，将对接口的调用交由代理类处理，即代理类相当于接口的实现。</p>
<p>但我们不能使用简单的代理模式，因为传统的代理模式要求我们事先知道将要被代理的类的信息。这样与我们想要的动态获取类的信息的思想不符合。所以应该要使用动态代理实现。</p>
<p>动态代理的好处是，我们不需要为每一个类写一个代理类，也不需要事先知道我们将会代理什么类。</p>
<p><strong>总</strong>：Retrofit 中的动态代理：</p>
<ul>
<li>在代码运行中，会动态创建 Api 接口的实现类，作为代理对象，代理接口的方法</li>
<li>在我们调用Api接口的实现类的listRepos方法时，会调用了 InvocationHandler 的 invoke方法。</li>
<li>本质上是在运行期，生成了 Api 接口的实现类，调用了 InvocationHandler 的 invoke方法。</li>
</ul>
<p>接下来看create()方法理解动态代理的过程。</p>
<p>首先我们要知道实现动态代理的两个方法：Proxy类的newProxyInstance和InvocationHandler的invoke方法。</p>
<h3 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy#newProxyInstance()"></a>Proxy#newProxyInstance()</h3><p>参数含义：</p>
<p><strong>loader</strong>：用于定义代理类的类加载器</p>
<p><strong>interfaces</strong>：代理类要实现的接口列表</p>
<p><strong>h</strong>：将方法调用分派给h（InvocationHandler）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,</span><br><span class="line">InvocationHandler h)&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="InvocationHandler-invoke"><a href="#InvocationHandler-invoke" class="headerlink" title="InvocationHandler#invoke()"></a>InvocationHandler#invoke()</h3><p>参数含义：</p>
<p><strong>proxy</strong>：代理类的实例</p>
<p><strong>method</strong>：需要代理的方法</p>
<p><strong>args</strong>：代理方法的参数数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>

<p>其实当我们调用listRepos（）方法的时候，实际上是调用InvocationHandler 的invoke（）方法。它获取到了我们的方法，参数等信息。然后根据我们在方法上的注解，去拼接为一个正常的OkHttp 请求，然后执行。</p>
<p>以上两个方法在Retrofit中的具体运用如下：</p>
<h3 id="Retrofit-create"><a href="#Retrofit-create" class="headerlink" title="Retrofit#create()"></a>Retrofit#create()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传进来的是不是接口，不是接口就抛出异常</span></span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(</span><br><span class="line">          service.getClassLoader(),</span><br><span class="line">          <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// 如果该方法是来自Object的方法，则遵循正常调用。</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">          Platform platform = Platform.get();</span><br><span class="line">            </span><br><span class="line">          <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">              ? platform.invokeDefaultMethod(method, service, proxy, args) :loadServiceMethod(method).invoke(args);<span class="comment">//1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释1处</p>
<p><strong>return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) :loadServiceMethod(method).invoke(args);</strong></p>
<p>首先，根据平台的特性去判断该方法是否为default方法 ，有些平台不支持default方法。platform.isDefaultMethod(method) 。</p>
<p>Java8以后，接口中可以有default方法，该方法可以在接口中实现，且一定要实现。</p>
<p>所以，当该方法在当前平台下属于default方法时，直接调用该方法即可，即platform.invokeDefaultMethod(method, service, proxy, args)</p>
<p>若该方法不是default方法，则调用loadServiceMethod(method).invoke(args)</p>
<h3 id="Retrofit-loadServiceMethod"><a href="#Retrofit-loadServiceMethod" class="headerlink" title="Retrofit#loadServiceMethod"></a>Retrofit#loadServiceMethod</h3><p>根据method去获取该方法的信息，如注解，参数，返回值等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//serviceMethodCache是一个ConcurrentHashMap，键是method，每次解析获取method的信息后，将其存入ConcurrentHashMap，这样可以避免重复的解析</span></span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServiceMethod-parseAnnotations"><a href="#ServiceMethod-parseAnnotations" class="headerlink" title="ServiceMethod#parseAnnotations()"></a>ServiceMethod#parseAnnotations()</h3><p>ServiceMethod位于retrofit的包下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="comment">//处理不正确的返回形式</span></span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        method,</span><br><span class="line">        <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">        returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注释1"><a href="#注释1" class="headerlink" title="注释1"></a>注释1</h4><p><strong>RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</strong></p>
<h5 id="RequestFactory-parseAnnotations"><a href="#RequestFactory-parseAnnotations" class="headerlink" title="RequestFactory#parseAnnotations()"></a>RequestFactory#parseAnnotations()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(retrofit, method).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Builder"><a href="#Builder" class="headerlink" title="Builder()"></a>Builder()</h5><p>RequestFactory的内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">   <span class="comment">//反射获取方法的注解</span></span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">   <span class="comment">//反射获取方法的参数类型</span></span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">//反射获取方法的参数的注解</span></span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Builder-build"><a href="#Builder-build" class="headerlink" title="Builder#build()"></a>Builder#build()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">RequestFactory <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">      <span class="comment">//解析方法注解并赋值给其成员变量</span></span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          method,</span><br><span class="line">          <span class="string">&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span></span><br><span class="line">              + <span class="string">&quot;request body (e.g., @POST).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    parameterHandlers[p] =</span><br><span class="line">        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Missing either @%s URL or @Url parameter.&quot;</span>, httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Non-body HTTP method cannot contain @Body.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Form-encoded method must contain at least one @Field.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Multipart method must contain at least one @Part.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//将builder对象作为参数传给RequestFactory的构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注释2"><a href="#注释2" class="headerlink" title="注释2"></a>注释2</h4><p><strong>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">  <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  Type adapterType;</span><br><span class="line">  <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="comment">//...省略了关于kotlin的逻辑</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    adapterType = method.getGenericReturnType();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">      createCallAdapter(retrofit, method, adapterType, annotations);<span class="comment">//2.1</span></span><br><span class="line">    </span><br><span class="line">  Type responseType = callAdapter.responseType();</span><br><span class="line">  <span class="keyword">if</span> (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        method,</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">            + getRawType(responseType).getName()</span><br><span class="line">            + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO support Unit for Kotlin?</span></span><br><span class="line">  <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">&quot;HEAD&quot;</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HEAD method must use Void as response type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">      createResponseConverter(retrofit, method, responseType);<span class="comment">//2.2</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  okhttp3.Call.Factory callFactory = retrofit.callFactory;<span class="comment">//2.3</span></span><br><span class="line">  <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<span class="comment">//2.4</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForResponse&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">    <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">        <span class="keyword">new</span> SuspendForBody&lt;&gt;(</span><br><span class="line">            requestFactory,</span><br><span class="line">            callFactory,</span><br><span class="line">            responseConverter,</span><br><span class="line">            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">            continuationBodyNullable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注释2-1"><a href="#注释2-1" class="headerlink" title="注释2.1"></a>注释2.1</h5><p><strong>CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);</strong></p>
<p>最终执行的主要逻辑如下，即到retrofit中的callAdapterFactories寻找对应的callAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">  CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>retrofit中的callAdapterFactories的初始值其实是根据根据不同平台默认创建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">List&lt;? extends CallAdapter.Factory&gt; defaultCallAdapterFactories =</span><br><span class="line">    platform.createDefaultCallAdapterFactories(callbackExecutor);</span><br><span class="line">callAdapterFactories.addAll(defaultCallAdapterFactories);</span><br></pre></td></tr></table></figure>

<p>但也可以通过代码动态添加CallAdapterFactory</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CallAdapter.Factory factory = RxJava2CallAdapterFactory.create();</span><br><span class="line">Retrofit retrofit;</span><br><span class="line">retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;http://localhost:1&quot;</span>)</span><br><span class="line">    .addConverterFactory(<span class="keyword">new</span> StringConverterFactory())</span><br><span class="line">    .addCallAdapterFactory(factory)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h6 id="Retrofit-addCallAdapterFactory"><a href="#Retrofit-addCallAdapterFactory" class="headerlink" title="Retrofit#addCallAdapterFactory"></a>Retrofit#addCallAdapterFactory</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">  callAdapterFactories.add(Objects.requireNonNull(factory, <span class="string">&quot;factory == null&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callAdapterFactories中的一个常用的CallAdapterFactory为DefaultCallAdapterFactory，我们可以看一下它的get方法来理解CallAdapter的获取流程</p>
<h6 id="DefaultCallAdapterFactory-get"><a href="#DefaultCallAdapterFactory-get" class="headerlink" title="DefaultCallAdapterFactory#get()"></a>DefaultCallAdapterFactory#get()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">    Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Executor executor =</span><br><span class="line">      Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">          ? <span class="keyword">null</span></span><br><span class="line">          : callbackExecutor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注释2-2"><a href="#注释2-2" class="headerlink" title="注释2.2"></a>注释2.2</h5><p><strong>Converter&lt;ResponseBody, ResponseT&gt; responseConverter =<br>​      createResponseConverter(retrofit, method, responseType);</strong></p>
<p>  遍历找到合适的转换器 ，也就是我们在构造retrofit时常用的addConverterFactory，通过addConverterFactory添加的转换器会在这里被寻找到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addConverterFactory(GsonConverterFactory.create())</span><br></pre></td></tr></table></figure>

<h5 id="注释2-3"><a href="#注释2-3" class="headerlink" title="注释2.3"></a>注释2.3</h5><p>callFactory是Retrofit类里的，是在build时创建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">  callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注释2-4"><a href="#注释2-4" class="headerlink" title="注释2.4"></a>注释2.4</h5><p>如果不是 Kotlin 挂起函数，则返回 CallAdapted 对象</p>
<p>CallAdapted是HttpServiceMethod的子类，HttpServiceMethod是ServiceMethod的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br></pre></td></tr></table></figure>



<p>所以，create里的loadServiceMethod(method).invoke(args);实际调用的是CallAdapted对象的invoke(),也就是该对象从HttpServiceMethod继承的invoke()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);<span class="comment">//2.4.1</span></span><br><span class="line">  <span class="keyword">return</span> adapt(call, args);<span class="comment">//2.4.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="注释2-4-1"><a href="#注释2-4-1" class="headerlink" title="注释2.4.1"></a>注释2.4.1</h6><p> <strong>Call<ResponseT> call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</strong></p>
<p>用OkHttpCall去创建Call类型的实例，看一下它对execute()方法的实现。有过安卓开发经验的人应该知道，我们通常用call.execute()开启网络请求。</p>
<h6 id="OkHttpCall-execute"><a href="#OkHttpCall-execute" class="headerlink" title="OkHttpCall#execute()"></a>OkHttpCall#execute()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    call = getRawCall();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看这里的call = getRawCall();</p>
<h6 id="OkHttpCall-getRawCall"><a href="#OkHttpCall-getRawCall" class="headerlink" title="OkHttpCall#getRawCall()"></a>OkHttpCall#getRawCall()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">getRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call = rawCall;</span><br><span class="line">  <span class="keyword">if</span> (call != <span class="keyword">null</span>) <span class="keyword">return</span> call;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-throw previous failures if this isn&#x27;t the first attempt.</span></span><br><span class="line">  <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and remember either the success or the failure.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rawCall = createRawCall();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException | Error | IOException e) &#123;</span><br><span class="line">    throwIfFatal(e); <span class="comment">// Do not assign a fatal error to creationFailure.</span></span><br><span class="line">    creationFailure = e;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getRawCall()方法就是判断有没有初始化call，没有就create</p>
<h6 id="OkHttpCall-createRawCall"><a href="#OkHttpCall-createRawCall" class="headerlink" title="OkHttpCall#createRawCall()"></a>OkHttpCall#createRawCall()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用我们创建OkHttpCall时传入的<strong>callFactory</strong>，它是okhttp3.Call.Factory类型的。即注释2.3创建的 callFactory = new OkHttpClient();</p>
<p><strong>requestFactory</strong>是在注释1处创建的那个解析了注释的requestFactory。</p>
<p>继续看注释2.4.1中的parseResponse方法</p>
<h6 id="OkHttpCall-parseResponse"><a href="#OkHttpCall-parseResponse" class="headerlink" title="OkHttpCall#parseResponse"></a>OkHttpCall#parseResponse</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse =</span><br><span class="line">      rawResponse</span><br><span class="line">          .newBuilder()</span><br><span class="line">          .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingResponseBody catchingBody = <span class="keyword">new</span> ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    T body = responseConverter.convert(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>T body = responseConverter.convert(catchingBody);</strong></p>
<p>调用我们创建OkHttpCall传入的responseConverter解析返回值</p>
<h6 id="注释2-4-2"><a href="#注释2-4-2" class="headerlink" title="注释2.4.2"></a>注释2.4.2</h6><p><strong>return adapt(call, args);</strong></p>
<p>这里的adapt方法是由CallAdapte实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的callAdapter就是注释2.1处我们遍历去寻找的那个callAdapterFactories中生成的。</p>
<p>在DefaultCallAdapterFactory中，返回值如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>在DefaultCallAdapterFactory中，一般情况，adapt方法只是将参数返回。</p>
<p>这里的返回值是Call<Object>，其实也就是我们在定义Api接口时规定的返回值类型。</p>
<p>这里就释了为什么我们create后生成的对象具有与Api接口定义相同的方法。</p>
<p>比如在我们不设置CallAdapterFactory时，默认返回的是Call<Object>类型，也就是Api接口里定义的返回类型。</p>
<p>当然，我们常用的CallAdapterFactory还有上面提到的RxJava2CallAdapterFactory。</p>
<h6 id="RxJava2CallAdapterFactory-get"><a href="#RxJava2CallAdapterFactory-get" class="headerlink" title="RxJava2CallAdapterFactory#get()"></a>RxJava2CallAdapterFactory#get()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">    Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  Class&lt;?&gt; rawType = getRawType(returnType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rawType == Completable.class) &#123;</span><br><span class="line">    <span class="comment">// Completable is not parameterized (which is what the rest of this method deals with) so it</span></span><br><span class="line">    <span class="comment">// can only be created with a single configuration.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RxJava2CallAdapter(</span><br><span class="line">        Void.class, scheduler, isAsync, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继续看RxJava2CallAdapter的adpt()方法</p>
<h6 id="RxJava2CallAdapter-adpt"><a href="#RxJava2CallAdapter-adpt" class="headerlink" title="RxJava2CallAdapter#adpt()"></a>RxJava2CallAdapter#adpt()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">  Observable&lt;Response&lt;R&gt;&gt; responseObservable =</span><br><span class="line">      isAsync ? <span class="keyword">new</span> CallEnqueueObservable&lt;&gt;(call) : <span class="keyword">new</span> CallExecuteObservable&lt;&gt;(call);</span><br><span class="line"></span><br><span class="line">  Observable&lt;?&gt; observable;</span><br><span class="line">  <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> ResultObservable&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> BodyObservable&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observable = responseObservable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (scheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">    observable = observable.subscribeOn(scheduler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">    <span class="comment">// We only ever deliver a single value, and the RS spec states that you MUST request at least</span></span><br><span class="line">    <span class="comment">// one element which means we never need to honor backpressure.</span></span><br><span class="line">    <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.MISSING);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> RxJavaPlugins.onAssembly(observable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下返回的Observable的子类。这是因为它要适配RxJava，通常我们使用RxJava时Api接口的返回值为Observable。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在开发中常常遇见一种情况：实现某一个功能可以有多种算法，我们根据实际情况选择不同的算法或策略来完成该功能。针对这种情况，一种常规的方法是将多种算法写在一个类中，该类提供多种算法，每一个方法对应一个算法，用户根据自己的需求调用这些方法。也可以将这些算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来选择具体的算法。</p>
<p>这两种实现方式我们都可以称为硬编码。当很多个算法集中在一个类中时，这个类就会变得臃肿，也会使维护成本提高。这明显违法了开闭原则和单一职责原则。</p>
<p>如果将这些算法或策略抽象出来，提供一个统一的接口，不同的算法或策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法的动态替换，这种模式的可扩展性、可维护性也就更高。这就是策略模式的思想。</p>
<p>上面我们提到了转换器，可以在构建retrofit时用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addConverterFactory(GsonConverterFactory.create())</span><br></pre></td></tr></table></figure>

<p>添加转换器的工厂，以便之后用它来构造转换器。</p>
<p>所有的转换器都需要实现接口Converter。</p>
<p>Converter接口有一个convert方法，用于将从服务器上获取的返回值转换为需要的类型。不同的返回类型，需要不同的转换器去解析。每一种解析方式，就相当于一种策略，我们根据不同需求选择不同的策略，便是策略模式的应用场景。</p>
<h3 id="在Retrofit中解决的问题"><a href="#在Retrofit中解决的问题" class="headerlink" title="在Retrofit中解决的问题"></a>在Retrofit中解决的问题</h3><p>Retrofit在进行网络请求获得从服务端发来的数据后，需要对这些Json或Xml格式的数据进行解析，变成用户所需要的数据类型。</p>
<p>在Retrofit中通过转换器将获得的数据进行转换，然而不同的数据格式需要不同的转换器，不同的转换器中有不同的算法。需要根据实际情况进行转换器的选择。所以Retrofit将转换这一功能进行抽象，定义为Converter接口，它拥有convert方法，可以进行数据的解析与转换。</p>
<p>Retrofit内置的转换器有GsonResponseBodyConverter<strong>、</strong></p>
<p>JacksonResponseBodyConverter、JaxbResponseConverter等。它们可以对Json或Xml格式的数据进行解析与转换。除了内置的转换器以外，我们也可以实现Converter接口自定义转换器。</p>
<p>这些转换器可以在我们创建Retrofit时添加进去，这样，就是完成了对转换策略的选择。它使得程序的扩展性提高。</p>
<p>接下来看一下我们常用的转换器。</p>
<h3 id="GsonResponseBodyConverter"><a href="#GsonResponseBodyConverter" class="headerlink" title="GsonResponseBodyConverter"></a>GsonResponseBodyConverter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonResponseBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">  GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">&quot;JSON document was not fully consumed.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，还有支持Json解析的JacksonResponseBodyConverter、支持Xml解析的JaxbResponseConverter</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>将一个类的接口转换成用户希望的另一个接口</p>
<h3 id="在Retrofit的应用"><a href="#在Retrofit的应用" class="headerlink" title="在Retrofit的应用"></a>在Retrofit的应用</h3><p>在上面介绍动态代理模式的时候我们提到过CallAdapter接口，它拥有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br></pre></td></tr></table></figure>

<p>RxJava2CallAdapter也是CallAdapter的实现类。</p>
<p>这个adapt方法的作用是将传进来的Call类型对象转换成另一个类型。</p>
<p>在我们不手动添加CallAdapterFactory时，默认会将传入的Call类型对象返回</p>
<p>而若我们添加了RxJava2CallAdapterFactory，RxJava2CallAdapter会将传入的Call转换成为Observable类型或者Observable的变种Flowable、Single等。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>动态地给一个对象增加一些额外的功能，但不会改变对象的接口。这是与适配器模式的最大区别。</p>
<h3 id="在Retrofit中的应用"><a href="#在Retrofit中的应用" class="headerlink" title="在Retrofit中的应用"></a>在Retrofit中的应用</h3><p>在DefaultCallAdapterFactory中对CallAdapter的实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到它在adapt中定义了两种返回值类型，即传入的Call类型（实际上是OkHttpCall）和ExecutorCallbackCall类型。</p>
<p>OkHttpCall是Call接口的实例。而ExecutorCallbackCall是Call接口的装饰类，它不仅实现了Call接口，它还拥有一个Call类型的引用，这个引用对象是在创建ExecutorCallbackCall时传入的，在这里为传入的OkHttpCall类型对象。</p>
<p>真正执行网络请求的是传入的Call类型的实例，即OkHttpCall类型对象。而ExecutorCallbackCall为Call增加了指定线程的功能。在构造ExecutorCallbackCall时，可以传入Executor类型的实例。</p>
<p>在调用enqueue()方法时，实际调用的是OkHttpCall的enqueue方法。而回调的方法是在传入的Executor类型实例的线程中的。</p>
<p>如果你希望在主线程接受回调，通常需要通过Handler转换到主线程上去。而ExecutorCallbackCall可以指定线程，所以可以用于转换到主线程中。</p>
]]></content>
  </entry>
  <entry>
    <title>从HTML文件导入课表教程</title>
    <url>/2022/02/22/%E4%BB%8EHTML%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E8%AF%BE%E8%A1%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>以Chrome浏览器为例</strong></p>
<p>1、登录学校教务系统找到含有课表信息的网页</p>
<p>2、在该网页界面右键，选择另存为并保存</p>
<a id="more"></a>



<p><img src="https://s2.loli.net/2022/02/22/JlAdq2bEzXuI3wY.png" alt="屏幕截图(283).png"></p>
<p>3、将该html文件发送到手机上并在手机上保存</p>
<p>4、在本App<strong>从HTML导入</strong>界面内选择学校/教务类型</p>
<p>5、在本App<strong>从HTML导入</strong>界面内选择html文件</p>
<p>6、找到刚刚在手机上保存的html文件</p>
<p>7、在本App<strong>从HTML导入</strong>界面内点击导入课程即可</p>
]]></content>
  </entry>
  <entry>
    <title>OkHttp</title>
    <url>/2022/02/26/OkHttp/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Get-a-URL"><a href="#Get-a-URL" class="headerlink" title="Get a URL"></a>Get a URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">Response response = client.newCall(request).execute()</span><br></pre></td></tr></table></figure>

<p>可以看到，完成一个Get请求需要OkHttpClient类型对象和Request类型对象。</p>
<a id="more"></a>



<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。</p>
<p>建造者模式关注该对象是如何一步一步创建而成的，对于用户而言，无须知道创建过程和内部组成细节。</p>
<h3 id="OkHttpClient的创建"><a href="#OkHttpClient的创建" class="headerlink" title="OkHttpClient的创建"></a>OkHttpClient的创建</h3><h4 id="由构造器直接创建"><a href="#由构造器直接创建" class="headerlink" title="由构造器直接创建"></a>由构造器直接创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br></pre></td></tr></table></figure>



<h4 id="由Builder创建"><a href="#由Builder创建" class="headerlink" title="由Builder创建"></a>由Builder创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">       .addInterceptor(<span class="keyword">new</span> HttpLoggingInterceptor())</span><br><span class="line">       .cache(<span class="keyword">new</span> Cache(cacheDir, cacheSize))</span><br><span class="line">       .build();</span><br></pre></td></tr></table></figure>

<p>一步步来看这个过程，首先new 了一个OkHttpClient.Builder()，即一个Builder类型的对象，这个Builder是OkHttpClient的内部类。</p>
<h5 id="Builder的构造器"><a href="#Builder的构造器" class="headerlink" title="Builder的构造器"></a>Builder的构造器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">  eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  <span class="keyword">if</span> (proxySelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxySelector = <span class="keyword">new</span> NullProxySelector();</span><br><span class="line">  &#125;</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">  authenticator = Authenticator.NONE;</span><br><span class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="keyword">true</span>;</span><br><span class="line">  followRedirects = <span class="keyword">true</span>;</span><br><span class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</span><br><span class="line">  callTimeout = <span class="number">0</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">  pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是对Builder中的参数进行初始化赋值操作。</p>
<h5 id="Builder-addInterceptor"><a href="#Builder-addInterceptor" class="headerlink" title="Builder#addInterceptor()"></a>Builder#addInterceptor()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interceptor == null&quot;</span>);</span><br><span class="line">  interceptors.add(interceptor);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addInterceptor方法为Builder中的List<Interceptor> interceptors类型的interceptors添加值，返回的是原先的Builder类型对象</p>
<h5 id="Builder-cache"><a href="#Builder-cache" class="headerlink" title="Builder#cache()"></a>Builder#cache()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">cache</span><span class="params">(<span class="meta">@Nullable</span> Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  <span class="keyword">this</span>.internalCache = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache方法同理，对Builder中的cache参数赋值。返回的依旧是原先的Builder类型对象。</p>
<p><strong>这些方法其实和常见的set方法很像，但最大的区别是，通常的set方法不返回任何值，仅仅可以一次调用。而Builder类中的这些方法依旧返回在原先基础上修改过的Builder对象，所以我们可以在这个Builder对象上继续修改，实现我们所见的连续调用操作。</strong></p>
<p><strong><em>但至此，我们只是构建好了Builder类型对象，这与OkHttpClient的创建有什么联系呢？</em></strong></p>
<p>在用Builder创建时，除了调用上述的两个返回值类型为Builder的方法，还调用了build方法。</p>
<h5 id="Builder-build"><a href="#Builder-build" class="headerlink" title="Builder#build()"></a>Builder#build()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OkHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的返回值是OkHttpClient。它调用了OkHttpClient的构造方法，并将自身作为参数传入。</p>
<h5 id="OkHttpClient-Builder-builder"><a href="#OkHttpClient-Builder-builder" class="headerlink" title="OkHttpClient(Builder builder)"></a>OkHttpClient(Builder builder)</h5><p>用Builder的参数为OkHttpClient赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher;</span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy;</span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols;</span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector;</span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar;</span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache;</span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">    isTLS = isTLS || spec.isTls();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    X509TrustManager trustManager = Util.platformTrustManager();</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sslSocketFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Platform.get().configureSslSocketFactory(sslSocketFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool;</span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.callTimeout = builder.callTimeout;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout;</span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout;</span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (interceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Null interceptor: &quot;</span> + interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (networkInterceptors.contains(<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Null network interceptor: &quot;</span> + networkInterceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实，OkHttpClient的无参构造方法也是调用了参数为Builder的构造方法，只是它传入的是默认创建的Builder</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public OkHttpClient() &#123;</span><br><span class="line">  this(new Builder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="由newBuilder创建"><a href="#由newBuilder创建" class="headerlink" title="由newBuilder创建"></a>由newBuilder创建</h4><p>你可以使用newBuilder()来定制一个<strong>共享</strong>的OkHttpClient实例。这将构建共享相同连接池、线程池和配置的客户机。使用构建器方法为特定目的配置派生客户机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient eagerClient = client.newBuilder().</span><br><span class="line"> readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br></pre></td></tr></table></figure>

<p>client是已有的OkHttpClient实例,newBuilder是OkHttpClient类中的方法</p>
<h5 id="OkHttpClient-newBuilder"><a href="#OkHttpClient-newBuilder" class="headerlink" title="OkHttpClient#newBuilder()"></a>OkHttpClient#newBuilder()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将自身作为参数传给Builder的构造方法</p>
<h5 id="Builder-OkHttpClient-okHttpClient"><a href="#Builder-OkHttpClient-okHttpClient" class="headerlink" title="Builder(OkHttpClient okHttpClient)"></a>Builder(OkHttpClient okHttpClient)</h5><p>用OkHttpClient对象的参数初始化Builder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Builder(OkHttpClient okHttpClient) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = okHttpClient.dispatcher;</span><br><span class="line">  <span class="keyword">this</span>.proxy = okHttpClient.proxy;</span><br><span class="line">  <span class="keyword">this</span>.protocols = okHttpClient.protocols;</span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = okHttpClient.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors.addAll(okHttpClient.interceptors);</span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors.addAll(okHttpClient.networkInterceptors);</span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = okHttpClient.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = okHttpClient.proxySelector;</span><br><span class="line">  <span class="keyword">this</span>.cookieJar = okHttpClient.cookieJar;</span><br><span class="line">  <span class="keyword">this</span>.internalCache = okHttpClient.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.cache = okHttpClient.cache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = okHttpClient.socketFactory;</span><br><span class="line">  <span class="keyword">this</span>.sslSocketFactory = okHttpClient.sslSocketFactory;</span><br><span class="line">  <span class="keyword">this</span>.certificateChainCleaner = okHttpClient.certificateChainCleaner;</span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = okHttpClient.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = okHttpClient.certificatePinner;</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = okHttpClient.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = okHttpClient.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = okHttpClient.connectionPool;</span><br><span class="line">  <span class="keyword">this</span>.dns = okHttpClient.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = okHttpClient.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = okHttpClient.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.callTimeout = okHttpClient.callTimeout;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = okHttpClient.connectTimeout;</span><br><span class="line">  <span class="keyword">this</span>.readTimeout = okHttpClient.readTimeout;</span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = okHttpClient.writeTimeout;</span><br><span class="line">  <span class="keyword">this</span>.pingInterval = okHttpClient.pingInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h3><ul>
<li>用于创建对象Builder其实是可以共享的，我们可以用同一个Builder类型的对象创建出不同的实例。</li>
<li>可以让用户不需要关心构造的具体细节，只需要指定想更改的参数。</li>
</ul>
<blockquote>
<p>OkHttp中的Request也用来建造者模式</p>
</blockquote>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。</p>
<p>责任链模式有两种情况，一种是要求具体的处理对象只能选择承担责任或把责任继续传递，不能承担责任后又继续将责任往下传。另一种是，一个责任可以被不同的对象接收，即不论当前对象是否处理该责任，都可以终止传递或继续传递。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>使用OkHttp进行Get请求的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response response = client.newCall(request).execute()</span><br></pre></td></tr></table></figure>

<p>client.newCall(request)将会返回一个Call类型的实例，实际为RealCall类的对象。它的execute()方法如下</p>
<h4 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall#execute()"></a>RealCall#execute()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下，它的返回值是 getResponseWithInterceptorChain()。这个方法就涉及到了责任链模式</p>
<h3 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall#getResponseWithInterceptorChain()"></a>RealCall#getResponseWithInterceptorChain()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"><span class="comment">//0表示index</span></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将所有拦截器放入一个list中，传给RealInterceptorChain构建对象。然后调用Response response = chain.proceed(originalRequest);即可得到response。</p>
<h3 id="RealInterceptorChain-proceed"><a href="#RealInterceptorChain-proceed" class="headerlink" title="RealInterceptorChain#proceed()"></a>RealInterceptorChain#proceed()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, <span class="meta">@Nullable</span> Exchange exchange)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">&quot; must retain the same host and port&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptor</span><br><span class="line">          + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn&#x27;t null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">          <span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned a response with no body&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的interceptors是构造RealInterceptorChain时传入的拦截器list</p>
</blockquote>
<p>这个方法将会调用当前index的Interceptor实例,将</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">   RealInterceptorChain next = newRealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">       index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);<span class="comment">//这里的index+1了</span></span><br></pre></td></tr></table></figure>

<p>作为参数传给Interceptor的intercept方法得到response。</p>
<p>接下来看一下不同的Interceptor的intercept方法</p>
<h3 id="RetryAndFollowUpInterceptor-intercept"><a href="#RetryAndFollowUpInterceptor-intercept" class="headerlink" title="RetryAndFollowUpInterceptor#intercept()"></a>RetryAndFollowUpInterceptor#intercept()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = chain.request();</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">      success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">      <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>response = realChain.proceed(request, transmitter, null);</strong></p>
<p>继续调用chain的proceed方法。也就是上面说的RealInterceptorChain的proceed方法。</p>
<h3 id="BridgeInterceptor-intercept"><a href="#BridgeInterceptor-intercept" class="headerlink" title="BridgeInterceptor#intercept()"></a>BridgeInterceptor#intercept()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面的Interceptor一样，继续调用chain的proceed()</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>其他的Interceptor也同理。无论它们其中的逻辑多复杂，都会涉及到对chain的proceed()方法调用</strong>，这样，request就一层一层地传递下去了。</p>
<p>且每个Interceptor的response都与chain的proceed()的返回值有关。这个返回值其实是下一个拦截器的response，下一个的response同理。这样就可以通过连续调用，在最开始的chain中得到调用过所有拦截器后的response了。</p>
<blockquote>
<p>注意我这里说的是当前Interceptor的response与它后面的Interceptor的response有关，并不是等于的关系。因为当前的Interceptor往往还会根据获得的response进行进一步的操作，才得到最终要返回的response。</p>
</blockquote>
<p>所以一个Interceptor的操作分为三个步骤，准备，发送，解析结果。</p>
<h3 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h3><ul>
<li><p>addInterceptor(Interceptor)，这是由开发者设置的，会按照开发者的要求，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加。</p>
</li>
<li><p>RetryAndFollowUpInterceptor——失败和重定向拦截器</p>
</li>
<li><p>BridgeInterceptor——封装request和response拦截器</p>
</li>
<li><p>CacheInterceptor——缓存相关的过滤器，负责读取缓存直接返回、更新缓存</p>
</li>
<li><p>ConnectInterceptor——连接服务，负责和服务器建立连接 </p>
</li>
<li><p>CallServerInterceptor——执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据 进行http请求报文的封装与请求报文的解析f</p>
</li>
</ul>
<h3 id="详解各个拦截器"><a href="#详解各个拦截器" class="headerlink" title="详解各个拦截器"></a>详解各个拦截器</h3><p><strong><em>这里只关注拦截器的intercept方法</em></strong></p>
<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><h5 id="intercept"><a href="#intercept" class="headerlink" title="intercept"></a>intercept</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Override <span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//chain.request()的request是构建chain时传入的</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response;</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 继续调用后面的拦截器</span></span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// 试图通过路由连接失败。请求还没有发送</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 试图与服务器通信失败。请求可能已经发送。</span></span><br><span class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 网络调用抛出一个异常。释放任何资源。</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在之前的response，请用之前的response构建它。这样的response没有body</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(<span class="keyword">null</span>)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Exchange exchange = Internal.instance.exchange(response);</span><br><span class="line">      Route route = exchange != <span class="keyword">null</span> ? exchange.connection().route() : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据response及其状态码判断是否进行重试或重定向。如果不需要，则返回null。否则找出响应接收userResponse的HTTP请求。然后添加身份验证头、遵循重定向或处理客户端请求超时。</span></span><br><span class="line">      Request followUp = followUpRequest(response, route);</span><br><span class="line">        <span class="comment">// 如果followUp为空，表示不需要执行重试或者重定向，直接返回数据</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">      RequestBody followUpBody = followUp.body();</span><br><span class="line">        <span class="comment">// 如果followUp为null，followUpBody不为空，并且只需要请求一次时，那么就返回response；</span></span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange.detachWithViolence();</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">  	  <span class="comment">// 判断重试或者重定向的次数是否超过最大的次数，是的话则抛出异常；</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: &quot;</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">	  <span class="comment">// 将需要重试或者重定向的请求赋值给新的请求；</span></span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><h5 id="intercept-1"><a href="#intercept-1" class="headerlink" title="intercept"></a>intercept</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//封装request的Content-Type</span></span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line">		<span class="comment">//封装request的Content-Length</span></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//封装request的Host</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Host&quot;</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//封装request的Connection</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们添加了一个“Accept-Encoding: gzip”报头字段，我们也要负责解压传输流。</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//如果Accept-Encoding为null且Range为null,为Accept-Encoding添加gzip字段</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//封装request的Cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//封装request的User-Agent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"><span class="comment">//transparentGzip是之前设置的标志位</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">&quot;gzip&quot;</span>.equalsIgnoreCase(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        <span class="comment">//删除一些headers</span></span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">          .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><h5 id="intercept-2"><a href="#intercept-2" class="headerlink" title="intercept"></a>intercept</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这里的cache是client.internalCache()，是构造CacheInterceptor的参数</span></span><br><span class="line">  Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="keyword">null</span>;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();<span class="comment">//2</span></span><br><span class="line">   <span class="comment">//传向network的request, 如果为 null 表示不使用网络</span></span><br><span class="line">  Request networkRequest = strategy.networkRequest;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//用于返回或验证的cached response;如果为null表示不使用缓存</span></span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//跟踪满足缓存策略的HTTP响应。</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cache.trackResponse(strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body());<span class="comment">//因为cacheResponse == null，表示不使用缓存。 所以关闭cacheCandidate</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不允许使用网络，并且不使用缓存，返回504状态，body为空</span></span><br><span class="line">   <span class="comment">//Unsatisfiable Request (only-if-cached)</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不需要使用网络数据或者禁止使用网络，那么就直接返回缓存的数据；</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果缓存数据不为空并且进行的请求code为304，表示数据没有变化，继续使用缓存数据；</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//在合并headers之后，在stripping Content-Encoding报头之前更新缓存</span></span><br><span class="line"> 	    cache.trackConditionalCacheHit();</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个intercept方法涉及很多知识点，我们逐步分析了解</p>
<h6 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h6><p><strong>强制缓存</strong>就是服务器会告诉客户端该怎么缓存，例如cache-Control 字段，随便举几个例子：</p>
<ul>
<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>
<li>max-age=xxx：表示缓存内容将在xxx秒后失效</li>
<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
</ul>
<p><strong>协商缓存</strong>就是需要客户端和服务器进行协商后再决定是否使用缓存，比如强制缓存过期失效了，就要再次请求服务器，并带上缓存标志，例如Etag。<br>客户端<strong>再次</strong>进行请求的时候，请求头带上If-None-Match，也就是之前服务器返回的Etag值。</p>
<blockquote>
<p>Etag值就是文件的唯一标示，服务器通过某个算法对资源进行计算，取得一串值(类似于文件的md5值)，之后将该值通过etag返回给客户端</p>
</blockquote>
<p>然后服务器就会将Etag值和服务器本身文件的Etag值进行比较，如果一样则数据没改变，就返回304，代表你要请求的数据没改变，你直接用就行啦。<br>如果不一致，就返回新的数据，这时候的响应码就是正常的200。</p>
<h6 id="注释1"><a href="#注释1" class="headerlink" title="注释1"></a>注释1</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response cacheCandidate = cache != <span class="keyword">null</span>? cache.get(chain.request()) : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这里的cache来自client.internalCache()，是构造CacheInterceptor的参数。</p>
<h6 id="注释2"><a href="#注释2" class="headerlink" title="注释2"></a>注释2</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure>

<p> new CacheStrategy.Factory(now, chain.request(), cacheCandidate)生成了CacheStrategy.Factory对象。</p>
<p>CacheStrategy.Factory（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">  <span class="keyword">this</span>.request = request;</span><br><span class="line">  <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis();</span><br><span class="line">    <span class="keyword">this</span>.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();</span><br><span class="line">    Headers headers = cacheResponse.headers();</span><br><span class="line">      <span class="comment">//解析headers构建Factory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">      String fieldName = headers.name(i);</span><br><span class="line">      String value = headers.value(i);</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;Date&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        servedDate = HttpDate.parse(value);</span><br><span class="line">        servedDateString = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Expires&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        expires = HttpDate.parse(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Last-Modified&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        lastModified = HttpDate.parse(value);</span><br><span class="line">        lastModifiedString = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ETag&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        etag = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Age&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        ageSeconds = HttpHeaders.parseSeconds(value, -<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheStrategy.Factory#get()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CacheStrategy candidate = getCandidate();</span><br><span class="line"><span class="comment">//onlyIfCached表示不要使用网络</span></span><br><span class="line">  <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheStrategy.Factory#getCandidate()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回要使用的策略（假设request可以使用网络）。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// No cached response.</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Drop the cached response if it&#x27;s missing a required handshake.</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果这个response不应该被存储，那么它就不应该被用作response源。只要持久性存储良好且规则不变，此检查就应该是多余的。</span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CacheControl requestCaching = request.cacheControl();</span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//强制缓存的检查</span></span><br><span class="line">      <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">      <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断强制缓存是否有效，是的话就返回缓存数据；</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到一个要添加到请求中的条件。</span></span><br><span class="line">    <span class="comment">//如果存在协商缓存，这些缓存是从cache中读出来的，具体在Factory里</span></span><br><span class="line">   <span class="comment">// 协商缓存的处理</span></span><br><span class="line">      String conditionName;</span><br><span class="line">      String conditionValue;</span><br><span class="line">    <span class="comment">// etag协商缓存</span></span><br><span class="line">      <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">      &#125; </span><br><span class="line">    <span class="comment">// Last-Modified协商缓存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">	<span class="comment">// 最后修改时间</span></span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// Last-Modified协商缓存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">    <span class="comment">// 服务器最后修改时间</span></span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">      &#125; </span><br><span class="line">   <span class="comment">// 没有协商缓存，返回一个空的Response的CacheStrategy；</span></span><br><span class="line">    <span class="keyword">else</span> &#123;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// 没有满足协商缓存的条件，返回常规的请求。</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">      Request conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p>封装了socket连接和TLS握手等逻辑</p>
<h5 id="intercept-3"><a href="#intercept-3" class="headerlink" title="intercept()"></a>intercept()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">  <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接的具体实现在transmitter.newExchange(chain, doExtensiveHealthChecks);方法中。</p>
<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>在上一个拦截器中建立完连接后，就需要在这个拦截器中进行发数据与读数据的工作了。</p>
<h5 id="intercept-4"><a href="#intercept-4" class="headerlink" title="intercept()"></a>intercept()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Exchange exchange = realChain.exchange();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">    <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">    <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">      exchange.flushRequest();</span><br><span class="line">      responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">      exchange.responseHeadersStart();</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">        <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">        exchange.flushRequest();</span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">            exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">        BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">            exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">        request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        bufferedRequestBody.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">      <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">        <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">        <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">        <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">        exchange.noNewExchangesOnConnection();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    exchange.noRequestBody();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">    exchange.finishRequest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">    exchange.responseHeadersStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(exchange.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">    <span class="comment">// try again to read the actual response</span></span><br><span class="line">    response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    code = response.code();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(exchange.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">      || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">    exchange.noNewExchangesOnConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">        <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体进行向服务器发送header和body以及接收服务器返回的数据的操作。</p>
<p>核心工作都由 HttpCodec 对象完成，而 HttpCodec 实际上利用的是 Okio，而 Okio 实际上还是用的 Socket</p>
]]></content>
  </entry>
  <entry>
    <title>从Excel文件导入课表教程</title>
    <url>/2022/02/26/%E4%BB%8EExcel%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E8%AF%BE%E8%A1%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>1、<a href="https://pan.baidu.com/s/1-7PuyBrwI77bEcHG5jL7nw">点此获取Excel表格模板</a></p>
<ul>
<li>提取码为1111</li>
</ul>
<p>2、从第二行起填入课程信息，课程名，教师，地点格式不限</p>
<p>3、周数、节数、星期几等信息必须为阿拉伯数字</p>
<p>4、星期几的数字范围为1~7，对应周一到周日</p>
<a id="more"></a>

<p>5、周数、节数的填入格式如下</p>
<ul>
<li><p>周数：</p>
<p>例子如下，根据实际情况选择</p>
<p><em>注意:</em></p>
<p>所填均为半角而非全角</p>
<p>括号是() ,不是（）</p>
<p>逗号是, 不是，</p>
<table>
<thead>
<tr>
<th>1~10</th>
</tr>
</thead>
<tbody><tr>
<td>1~20(双)</td>
</tr>
<tr>
<td>1~20(单)</td>
</tr>
<tr>
<td>1,2,3</td>
</tr>
<tr>
<td>1,2,5~10(单)</td>
</tr>
</tbody></table>
</li>
<li><p>节数：</p>
<p>例子如下</p>
<table>
<thead>
<tr>
<th>1~2</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
</tr>
</tbody></table>
</li>
</ul>
<p>6、表格内容详细例子如下</p>
<p><img src="https://s2.loli.net/2022/02/26/ePwAHDqpZdhNa3W.png" alt="屏幕截图(286).png"></p>
<p>7、保存时，注意保存类型，应同下图所示</p>
<p><img src="https://s2.loli.net/2022/02/26/C6oOcBTxYp2Nwem.png" alt="屏幕截图(288).png"></p>
<p>8、将该文件发送到手机上并在手机上保存</p>
<p>9、在本App<strong>从EXCEL导入</strong>界面内选择Excel文件</p>
<p>10、找到刚刚在手机上保存的后缀为.xls的文件</p>
<p>11、在本App<strong>从EXCEL导入</strong>界面内点击导入课程即可</p>
]]></content>
  </entry>
</search>
